// Generated by CommonJS Everywhere 0.9.7
(function (global) {
  function require(file, parentModule) {
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var module$ = {
        id: file,
        require: require,
        filename: file,
        exports: {},
        loaded: false,
        parent: parentModule,
        children: []
      };
    if (parentModule)
      parentModule.children.push(module$);
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = module$.exports;
    resolved.call(module$.exports, module$, module$.exports, dirname, file);
    module$.loaded = true;
    return require.cache[file] = module$.exports;
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
  };
  require.define = function (file, fn) {
    require.modules[file] = fn;
  };
  var process = function () {
      var cwd = '/';
      return {
        title: 'browser',
        version: 'v5.3.0',
        browser: true,
        env: {},
        argv: [],
        nextTick: global.setImmediate || function (fn) {
          setTimeout(fn, 0);
        },
        cwd: function () {
          return cwd;
        },
        chdir: function (dir) {
          cwd = dir;
        }
      };
    }();
  require.define('/dist/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.Accessibility = exports.DeclarationType = exports.ScopeType = exports.ScopeLookup = undefined;
    var _scopeLookup = require('/dist/scope-lookup.js', module);
    Object.defineProperty(exports, 'ScopeLookup', {
      enumerable: true,
      get: function get() {
        return _scopeLookup.default;
      }
    });
    var _scope = require('/dist/scope.js', module);
    Object.defineProperty(exports, 'ScopeType', {
      enumerable: true,
      get: function get() {
        return _scope.ScopeType;
      }
    });
    var _declaration = require('/dist/declaration.js', module);
    Object.defineProperty(exports, 'DeclarationType', {
      enumerable: true,
      get: function get() {
        return _declaration.DeclarationType;
      }
    });
    var _reference = require('/dist/reference.js', module);
    Object.defineProperty(exports, 'Accessibility', {
      enumerable: true,
      get: function get() {
        return _reference.Accessibility;
      }
    });
    exports.default = analyze;
    var _scopeAnalyzer = require('/dist/scope-analyzer.js', module);
    var _scopeAnalyzer2 = _interopRequireDefault(_scopeAnalyzer);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    if (typeof Map === 'undefined')
      require('/node_modules/es6-map/implement.js', module);
    if (typeof Symbol === 'undefined')
      require('/node_modules/es6-symbol/implement.js', module);
    function analyze(script) {
      return _scopeAnalyzer2.default.analyze(script);
    }
  });
  require.define('/node_modules/es6-symbol/implement.js', function (module, exports, __dirname, __filename) {
    'use strict';
    if (!require('/node_modules/es6-symbol/is-implemented.js', module)()) {
      Object.defineProperty(require('/node_modules/es5-ext/global.js', module), 'Symbol', {
        value: require('/node_modules/es6-symbol/polyfill.js', module),
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
  });
  require.define('/node_modules/es6-symbol/polyfill.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var d = require('/node_modules/d/index.js', module), validateSymbol = require('/node_modules/es6-symbol/validate-symbol.js', module), create = Object.create, defineProperties = Object.defineProperties, defineProperty = Object.defineProperty, objPrototype = Object.prototype, Symbol, HiddenSymbol, globalSymbols = create(null);
    var generateName = function () {
        var created = create(null);
        return function (desc) {
          var postfix = 0, name;
          while (created[desc + (postfix || '')])
            ++postfix;
          desc += postfix || '';
          created[desc] = true;
          name = '@@' + desc;
          defineProperty(objPrototype, name, d.gs(null, function (value) {
            defineProperty(this, name, d(value));
          }));
          return name;
        };
      }();
    HiddenSymbol = function Symbol(description) {
      if (this instanceof HiddenSymbol)
        throw new TypeError('TypeError: Symbol is not a constructor');
      return Symbol(description);
    };
    module.exports = Symbol = function Symbol(description) {
      var symbol;
      if (this instanceof Symbol)
        throw new TypeError('TypeError: Symbol is not a constructor');
      symbol = create(HiddenSymbol.prototype);
      description = description === undefined ? '' : String(description);
      return defineProperties(symbol, {
        __description__: d('', description),
        __name__: d('', generateName(description))
      });
    };
    defineProperties(Symbol, {
      for: d(function (key) {
        if (globalSymbols[key])
          return globalSymbols[key];
        return globalSymbols[key] = Symbol(String(key));
      }),
      keyFor: d(function (s) {
        var key;
        validateSymbol(s);
        for (key in globalSymbols)
          if (globalSymbols[key] === s)
            return key;
      }),
      hasInstance: d('', Symbol('hasInstance')),
      isConcatSpreadable: d('', Symbol('isConcatSpreadable')),
      iterator: d('', Symbol('iterator')),
      match: d('', Symbol('match')),
      replace: d('', Symbol('replace')),
      search: d('', Symbol('search')),
      species: d('', Symbol('species')),
      split: d('', Symbol('split')),
      toPrimitive: d('', Symbol('toPrimitive')),
      toStringTag: d('', Symbol('toStringTag')),
      unscopables: d('', Symbol('unscopables'))
    });
    defineProperties(HiddenSymbol.prototype, {
      constructor: d(Symbol),
      toString: d('', function () {
        return this.__name__;
      })
    });
    defineProperties(Symbol.prototype, {
      toString: d(function () {
        return 'Symbol (' + validateSymbol(this).__description__ + ')';
      }),
      valueOf: d(function () {
        return validateSymbol(this);
      })
    });
    defineProperty(Symbol.prototype, Symbol.toPrimitive, d('', function () {
      return validateSymbol(this);
    }));
    defineProperty(Symbol.prototype, Symbol.toStringTag, d('c', 'Symbol'));
    defineProperty(HiddenSymbol.prototype, Symbol.toPrimitive, d('c', Symbol.prototype[Symbol.toPrimitive]));
    defineProperty(HiddenSymbol.prototype, Symbol.toStringTag, d('c', Symbol.prototype[Symbol.toStringTag]));
  });
  require.define('/node_modules/es6-symbol/validate-symbol.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var isSymbol = require('/node_modules/es6-symbol/is-symbol.js', module);
    module.exports = function (value) {
      if (!isSymbol(value))
        throw new TypeError(value + ' is not a symbol');
      return value;
    };
  });
  require.define('/node_modules/es6-symbol/is-symbol.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function (x) {
      return x && (typeof x === 'symbol' || x['@@toStringTag'] === 'Symbol') || false;
    };
  });
  require.define('/node_modules/d/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var assign = require('/node_modules/es5-ext/object/assign/index.js', module), normalizeOpts = require('/node_modules/es5-ext/object/normalize-options.js', module), isCallable = require('/node_modules/es5-ext/object/is-callable.js', module), contains = require('/node_modules/es5-ext/string/#/contains/index.js', module), d;
    d = module.exports = function (dscr, value) {
      var c, e, w, options, desc;
      if (arguments.length < 2 || typeof dscr !== 'string') {
        options = value;
        value = dscr;
        dscr = null;
      } else {
        options = arguments[2];
      }
      if (dscr == null) {
        c = w = true;
        e = false;
      } else {
        c = contains.call(dscr, 'c');
        e = contains.call(dscr, 'e');
        w = contains.call(dscr, 'w');
      }
      desc = {
        value: value,
        configurable: c,
        enumerable: e,
        writable: w
      };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
    d.gs = function (dscr, get, set) {
      var c, e, options, desc;
      if (typeof dscr !== 'string') {
        options = set;
        set = get;
        get = dscr;
        dscr = null;
      } else {
        options = arguments[3];
      }
      if (get == null) {
        get = undefined;
      } else if (!isCallable(get)) {
        options = get;
        get = set = undefined;
      } else if (set == null) {
        set = undefined;
      } else if (!isCallable(set)) {
        options = set;
        set = undefined;
      }
      if (dscr == null) {
        c = true;
        e = false;
      } else {
        c = contains.call(dscr, 'c');
        e = contains.call(dscr, 'e');
      }
      desc = {
        get: get,
        set: set,
        configurable: c,
        enumerable: e
      };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
  });
  require.define('/node_modules/es5-ext/string/#/contains/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = require('/node_modules/es5-ext/string/#/contains/is-implemented.js', module)() ? String.prototype.contains : require('/node_modules/es5-ext/string/#/contains/shim.js', module);
  });
  require.define('/node_modules/es5-ext/string/#/contains/shim.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var indexOf = String.prototype.indexOf;
    module.exports = function (searchString) {
      return indexOf.call(this, searchString, arguments[1]) > -1;
    };
  });
  require.define('/node_modules/es5-ext/string/#/contains/is-implemented.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var str = 'razdwatrzy';
    module.exports = function () {
      if (typeof str.contains !== 'function')
        return false;
      return str.contains('dwa') === true && str.contains('foo') === false;
    };
  });
  require.define('/node_modules/es5-ext/object/is-callable.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function (obj) {
      return typeof obj === 'function';
    };
  });
  require.define('/node_modules/es5-ext/object/normalize-options.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var forEach = Array.prototype.forEach, create = Object.create;
    var process = function (src, obj) {
      var key;
      for (key in src)
        obj[key] = src[key];
    };
    module.exports = function (options) {
      var result = create(null);
      forEach.call(arguments, function (options) {
        if (options == null)
          return;
        process(Object(options), result);
      });
      return result;
    };
  });
  require.define('/node_modules/es5-ext/object/assign/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = require('/node_modules/es5-ext/object/assign/is-implemented.js', module)() ? Object.assign : require('/node_modules/es5-ext/object/assign/shim.js', module);
  });
  require.define('/node_modules/es5-ext/object/assign/shim.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var keys = require('/node_modules/es5-ext/object/keys/index.js', module), value = require('/node_modules/es5-ext/object/valid-value.js', module), max = Math.max;
    module.exports = function (dest, src) {
      var error, i, l = max(arguments.length, 2), assign;
      dest = Object(value(dest));
      assign = function (key) {
        try {
          dest[key] = src[key];
        } catch (e) {
          if (!error)
            error = e;
        }
      };
      for (i = 1; i < l; ++i) {
        src = arguments[i];
        keys(src).forEach(assign);
      }
      if (error !== undefined)
        throw error;
      return dest;
    };
  });
  require.define('/node_modules/es5-ext/object/valid-value.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function (value) {
      if (value == null)
        throw new TypeError('Cannot use null or undefined');
      return value;
    };
  });
  require.define('/node_modules/es5-ext/object/keys/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = require('/node_modules/es5-ext/object/keys/is-implemented.js', module)() ? Object.keys : require('/node_modules/es5-ext/object/keys/shim.js', module);
  });
  require.define('/node_modules/es5-ext/object/keys/shim.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var keys = Object.keys;
    module.exports = function (object) {
      return keys(object == null ? object : Object(object));
    };
  });
  require.define('/node_modules/es5-ext/object/keys/is-implemented.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function () {
      try {
        Object.keys('primitive');
        return true;
      } catch (e) {
        return false;
      }
    };
  });
  require.define('/node_modules/es5-ext/object/assign/is-implemented.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function () {
      var assign = Object.assign, obj;
      if (typeof assign !== 'function')
        return false;
      obj = { foo: 'raz' };
      assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
      return obj.foo + obj.bar + obj.trzy === 'razdwatrzy';
    };
  });
  require.define('/node_modules/es5-ext/global.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = new Function('return this')();
  });
  require.define('/node_modules/es6-symbol/is-implemented.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function () {
      var symbol;
      if (typeof Symbol !== 'function')
        return false;
      symbol = Symbol('test symbol');
      try {
        String(symbol);
      } catch (e) {
        return false;
      }
      if (typeof Symbol.iterator === 'symbol')
        return true;
      if (typeof Symbol.isConcatSpreadable !== 'object')
        return false;
      if (typeof Symbol.iterator !== 'object')
        return false;
      if (typeof Symbol.toPrimitive !== 'object')
        return false;
      if (typeof Symbol.toStringTag !== 'object')
        return false;
      if (typeof Symbol.unscopables !== 'object')
        return false;
      return true;
    };
  });
  require.define('/node_modules/es6-map/implement.js', function (module, exports, __dirname, __filename) {
    'use strict';
    if (!require('/node_modules/es6-map/is-implemented.js', module)()) {
      Object.defineProperty(require('/node_modules/es5-ext/global.js', module), 'Map', {
        value: require('/node_modules/es6-map/polyfill.js', module),
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
  });
  require.define('/node_modules/es6-map/polyfill.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var clear = require('/node_modules/es5-ext/array/#/clear.js', module), eIndexOf = require('/node_modules/es5-ext/array/#/e-index-of.js', module), setPrototypeOf = require('/node_modules/es5-ext/object/set-prototype-of/index.js', module), callable = require('/node_modules/es5-ext/object/valid-callable.js', module), validValue = require('/node_modules/es5-ext/object/valid-value.js', module), d = require('/node_modules/d/index.js', module), ee = require('/node_modules/event-emitter/index.js', module), Symbol = require('/node_modules/es6-map/node_modules/es6-symbol/index.js', module), iterator = require('/node_modules/es6-iterator/valid-iterable.js', module), forOf = require('/node_modules/es6-iterator/for-of.js', module), Iterator = require('/node_modules/es6-map/lib/iterator.js', module), isNative = require('/node_modules/es6-map/is-native-implemented.js', module), call = Function.prototype.call, defineProperties = Object.defineProperties, getPrototypeOf = Object.getPrototypeOf, MapPoly;
    module.exports = MapPoly = function () {
      var iterable = arguments[0], keys, values, self;
      if (!(this instanceof MapPoly))
        throw new TypeError("Constructor requires 'new'");
      if (isNative && setPrototypeOf && Map !== MapPoly) {
        self = setPrototypeOf(new Map, getPrototypeOf(this));
      } else {
        self = this;
      }
      if (iterable != null)
        iterator(iterable);
      defineProperties(self, {
        __mapKeysData__: d('c', keys = []),
        __mapValuesData__: d('c', values = [])
      });
      if (!iterable)
        return self;
      forOf(iterable, function (value) {
        var key = validValue(value)[0];
        value = value[1];
        if (eIndexOf.call(keys, key) !== -1)
          return;
        keys.push(key);
        values.push(value);
      }, self);
      return self;
    };
    if (isNative) {
      if (setPrototypeOf)
        setPrototypeOf(MapPoly, Map);
      MapPoly.prototype = Object.create(Map.prototype, { constructor: d(MapPoly) });
    }
    ee(defineProperties(MapPoly.prototype, {
      clear: d(function () {
        if (!this.__mapKeysData__.length)
          return;
        clear.call(this.__mapKeysData__);
        clear.call(this.__mapValuesData__);
        this.emit('_clear');
      }),
      delete: d(function (key) {
        var index = eIndexOf.call(this.__mapKeysData__, key);
        if (index === -1)
          return false;
        this.__mapKeysData__.splice(index, 1);
        this.__mapValuesData__.splice(index, 1);
        this.emit('_delete', index, key);
        return true;
      }),
      entries: d(function () {
        return new Iterator(this, 'key+value');
      }),
      forEach: d(function (cb) {
        var thisArg = arguments[1], iterator, result;
        callable(cb);
        iterator = this.entries();
        result = iterator._next();
        while (result !== undefined) {
          call.call(cb, thisArg, this.__mapValuesData__[result], this.__mapKeysData__[result], this);
          result = iterator._next();
        }
      }),
      get: d(function (key) {
        var index = eIndexOf.call(this.__mapKeysData__, key);
        if (index === -1)
          return;
        return this.__mapValuesData__[index];
      }),
      has: d(function (key) {
        return eIndexOf.call(this.__mapKeysData__, key) !== -1;
      }),
      keys: d(function () {
        return new Iterator(this, 'key');
      }),
      set: d(function (key, value) {
        var index = eIndexOf.call(this.__mapKeysData__, key), emit;
        if (index === -1) {
          index = this.__mapKeysData__.push(key) - 1;
          emit = true;
        }
        this.__mapValuesData__[index] = value;
        if (emit)
          this.emit('_add', index, key);
        return this;
      }),
      size: d.gs(function () {
        return this.__mapKeysData__.length;
      }),
      values: d(function () {
        return new Iterator(this, 'value');
      }),
      toString: d(function () {
        return '[object Map]';
      })
    }));
    Object.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {
      return this.entries();
    }));
    Object.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));
  });
  require.define('/node_modules/es6-map/is-native-implemented.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function () {
      if (typeof Map === 'undefined')
        return false;
      return Object.prototype.toString.call(new Map) === '[object Map]';
    }();
  });
  require.define('/node_modules/es6-map/lib/iterator.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var setPrototypeOf = require('/node_modules/es5-ext/object/set-prototype-of/index.js', module), d = require('/node_modules/d/index.js', module), Iterator = require('/node_modules/es6-iterator/index.js', module), toStringTagSymbol = require('/node_modules/es6-map/node_modules/es6-symbol/index.js', module).toStringTag, kinds = require('/node_modules/es6-map/lib/iterator-kinds.js', module), defineProperties = Object.defineProperties, unBind = Iterator.prototype._unBind, MapIterator;
    MapIterator = module.exports = function (map, kind) {
      if (!(this instanceof MapIterator))
        return new MapIterator(map, kind);
      Iterator.call(this, map.__mapKeysData__, map);
      if (!kind || !kinds[kind])
        kind = 'key+value';
      defineProperties(this, {
        __kind__: d('', kind),
        __values__: d('w', map.__mapValuesData__)
      });
    };
    if (setPrototypeOf)
      setPrototypeOf(MapIterator, Iterator);
    MapIterator.prototype = Object.create(Iterator.prototype, {
      constructor: d(MapIterator),
      _resolve: d(function (i) {
        if (this.__kind__ === 'value')
          return this.__values__[i];
        if (this.__kind__ === 'key')
          return this.__list__[i];
        return [
          this.__list__[i],
          this.__values__[i]
        ];
      }),
      _unBind: d(function () {
        this.__values__ = null;
        unBind.call(this);
      }),
      toString: d(function () {
        return '[object Map Iterator]';
      })
    });
    Object.defineProperty(MapIterator.prototype, toStringTagSymbol, d('c', 'Map Iterator'));
  });
  require.define('/node_modules/es6-map/lib/iterator-kinds.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = require('/node_modules/es5-ext/object/primitive-set.js', module)('key', 'value', 'key+value');
  });
  require.define('/node_modules/es5-ext/object/primitive-set.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var forEach = Array.prototype.forEach, create = Object.create;
    module.exports = function (arg) {
      var set = create(null);
      forEach.call(arguments, function (name) {
        set[name] = true;
      });
      return set;
    };
  });
  require.define('/node_modules/es6-map/node_modules/es6-symbol/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = require('/node_modules/es6-map/node_modules/es6-symbol/is-implemented.js', module)() ? Symbol : require('/node_modules/es6-map/node_modules/es6-symbol/polyfill.js', module);
  });
  require.define('/node_modules/es6-map/node_modules/es6-symbol/polyfill.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var d = require('/node_modules/d/index.js', module), validateSymbol = require('/node_modules/es6-map/node_modules/es6-symbol/validate-symbol.js', module), create = Object.create, defineProperties = Object.defineProperties, defineProperty = Object.defineProperty, objPrototype = Object.prototype, NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null);
    if (typeof Symbol === 'function')
      NativeSymbol = Symbol;
    var generateName = function () {
        var created = create(null);
        return function (desc) {
          var postfix = 0, name, ie11BugWorkaround;
          while (created[desc + (postfix || '')])
            ++postfix;
          desc += postfix || '';
          created[desc] = true;
          name = '@@' + desc;
          defineProperty(objPrototype, name, d.gs(null, function (value) {
            if (ie11BugWorkaround)
              return;
            ie11BugWorkaround = true;
            defineProperty(this, name, d(value));
            ie11BugWorkaround = false;
          }));
          return name;
        };
      }();
    HiddenSymbol = function Symbol(description) {
      if (this instanceof HiddenSymbol)
        throw new TypeError('TypeError: Symbol is not a constructor');
      return SymbolPolyfill(description);
    };
    module.exports = SymbolPolyfill = function Symbol(description) {
      var symbol;
      if (this instanceof Symbol)
        throw new TypeError('TypeError: Symbol is not a constructor');
      symbol = create(HiddenSymbol.prototype);
      description = description === undefined ? '' : String(description);
      return defineProperties(symbol, {
        __description__: d('', description),
        __name__: d('', generateName(description))
      });
    };
    defineProperties(SymbolPolyfill, {
      for: d(function (key) {
        if (globalSymbols[key])
          return globalSymbols[key];
        return globalSymbols[key] = SymbolPolyfill(String(key));
      }),
      keyFor: d(function (s) {
        var key;
        validateSymbol(s);
        for (key in globalSymbols)
          if (globalSymbols[key] === s)
            return key;
      }),
      hasInstance: d('', NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill('hasInstance')),
      isConcatSpreadable: d('', NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill('isConcatSpreadable')),
      iterator: d('', NativeSymbol && NativeSymbol.iterator || SymbolPolyfill('iterator')),
      match: d('', NativeSymbol && NativeSymbol.match || SymbolPolyfill('match')),
      replace: d('', NativeSymbol && NativeSymbol.replace || SymbolPolyfill('replace')),
      search: d('', NativeSymbol && NativeSymbol.search || SymbolPolyfill('search')),
      species: d('', NativeSymbol && NativeSymbol.species || SymbolPolyfill('species')),
      split: d('', NativeSymbol && NativeSymbol.split || SymbolPolyfill('split')),
      toPrimitive: d('', NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill('toPrimitive')),
      toStringTag: d('', NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill('toStringTag')),
      unscopables: d('', NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill('unscopables'))
    });
    defineProperties(HiddenSymbol.prototype, {
      constructor: d(SymbolPolyfill),
      toString: d('', function () {
        return this.__name__;
      })
    });
    defineProperties(SymbolPolyfill.prototype, {
      toString: d(function () {
        return 'Symbol (' + validateSymbol(this).__description__ + ')';
      }),
      valueOf: d(function () {
        return validateSymbol(this);
      })
    });
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
      return validateSymbol(this);
    }));
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));
    defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag, d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));
    defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive, d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));
  });
  require.define('/node_modules/es6-map/node_modules/es6-symbol/validate-symbol.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var isSymbol = require('/node_modules/es6-map/node_modules/es6-symbol/is-symbol.js', module);
    module.exports = function (value) {
      if (!isSymbol(value))
        throw new TypeError(value + ' is not a symbol');
      return value;
    };
  });
  require.define('/node_modules/es6-map/node_modules/es6-symbol/is-symbol.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function (x) {
      return x && (typeof x === 'symbol' || x['@@toStringTag'] === 'Symbol') || false;
    };
  });
  require.define('/node_modules/es6-map/node_modules/es6-symbol/is-implemented.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function () {
      var symbol;
      if (typeof Symbol !== 'function')
        return false;
      symbol = Symbol('test symbol');
      try {
        String(symbol);
      } catch (e) {
        return false;
      }
      if (typeof Symbol.iterator === 'symbol')
        return true;
      if (typeof Symbol.isConcatSpreadable !== 'object')
        return false;
      if (typeof Symbol.iterator !== 'object')
        return false;
      if (typeof Symbol.toPrimitive !== 'object')
        return false;
      if (typeof Symbol.toStringTag !== 'object')
        return false;
      if (typeof Symbol.unscopables !== 'object')
        return false;
      return true;
    };
  });
  require.define('/node_modules/es6-iterator/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var clear = require('/node_modules/es5-ext/array/#/clear.js', module), assign = require('/node_modules/es5-ext/object/assign/index.js', module), callable = require('/node_modules/es5-ext/object/valid-callable.js', module), value = require('/node_modules/es5-ext/object/valid-value.js', module), d = require('/node_modules/d/index.js', module), autoBind = require('/node_modules/d/auto-bind.js', module), Symbol = require('/node_modules/es6-iterator/node_modules/es6-symbol/index.js', module), defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;
    module.exports = Iterator = function (list, context) {
      if (!(this instanceof Iterator))
        return new Iterator(list, context);
      defineProperties(this, {
        __list__: d('w', value(list)),
        __context__: d('w', context),
        __nextIndex__: d('w', 0)
      });
      if (!context)
        return;
      callable(context.on);
      context.on('_add', this._onAdd);
      context.on('_delete', this._onDelete);
      context.on('_clear', this._onClear);
    };
    defineProperties(Iterator.prototype, assign({
      constructor: d(Iterator),
      _next: d(function () {
        var i;
        if (!this.__list__)
          return;
        if (this.__redo__) {
          i = this.__redo__.shift();
          if (i !== undefined)
            return i;
        }
        if (this.__nextIndex__ < this.__list__.length)
          return this.__nextIndex__++;
        this._unBind();
      }),
      next: d(function () {
        return this._createResult(this._next());
      }),
      _createResult: d(function (i) {
        if (i === undefined)
          return {
            done: true,
            value: undefined
          };
        return {
          done: false,
          value: this._resolve(i)
        };
      }),
      _resolve: d(function (i) {
        return this.__list__[i];
      }),
      _unBind: d(function () {
        this.__list__ = null;
        delete this.__redo__;
        if (!this.__context__)
          return;
        this.__context__.off('_add', this._onAdd);
        this.__context__.off('_delete', this._onDelete);
        this.__context__.off('_clear', this._onClear);
        this.__context__ = null;
      }),
      toString: d(function () {
        return '[object Iterator]';
      })
    }, autoBind({
      _onAdd: d(function (index) {
        if (index >= this.__nextIndex__)
          return;
        ++this.__nextIndex__;
        if (!this.__redo__) {
          defineProperty(this, '__redo__', d('c', [index]));
          return;
        }
        this.__redo__.forEach(function (redo, i) {
          if (redo >= index)
            this.__redo__[i] = ++redo;
        }, this);
        this.__redo__.push(index);
      }),
      _onDelete: d(function (index) {
        var i;
        if (index >= this.__nextIndex__)
          return;
        --this.__nextIndex__;
        if (!this.__redo__)
          return;
        i = this.__redo__.indexOf(index);
        if (i !== -1)
          this.__redo__.splice(i, 1);
        this.__redo__.forEach(function (redo, i) {
          if (redo > index)
            this.__redo__[i] = --redo;
        }, this);
      }),
      _onClear: d(function () {
        if (this.__redo__)
          clear.call(this.__redo__);
        this.__nextIndex__ = 0;
      })
    })));
    defineProperty(Iterator.prototype, Symbol.iterator, d(function () {
      return this;
    }));
    defineProperty(Iterator.prototype, Symbol.toStringTag, d('', 'Iterator'));
  });
  require.define('/node_modules/es6-iterator/node_modules/es6-symbol/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = require('/node_modules/es6-iterator/node_modules/es6-symbol/is-implemented.js', module)() ? Symbol : require('/node_modules/es6-iterator/node_modules/es6-symbol/polyfill.js', module);
  });
  require.define('/node_modules/es6-iterator/node_modules/es6-symbol/polyfill.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var d = require('/node_modules/d/index.js', module), validateSymbol = require('/node_modules/es6-iterator/node_modules/es6-symbol/validate-symbol.js', module), create = Object.create, defineProperties = Object.defineProperties, defineProperty = Object.defineProperty, objPrototype = Object.prototype, NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null);
    if (typeof Symbol === 'function')
      NativeSymbol = Symbol;
    var generateName = function () {
        var created = create(null);
        return function (desc) {
          var postfix = 0, name, ie11BugWorkaround;
          while (created[desc + (postfix || '')])
            ++postfix;
          desc += postfix || '';
          created[desc] = true;
          name = '@@' + desc;
          defineProperty(objPrototype, name, d.gs(null, function (value) {
            if (ie11BugWorkaround)
              return;
            ie11BugWorkaround = true;
            defineProperty(this, name, d(value));
            ie11BugWorkaround = false;
          }));
          return name;
        };
      }();
    HiddenSymbol = function Symbol(description) {
      if (this instanceof HiddenSymbol)
        throw new TypeError('TypeError: Symbol is not a constructor');
      return SymbolPolyfill(description);
    };
    module.exports = SymbolPolyfill = function Symbol(description) {
      var symbol;
      if (this instanceof Symbol)
        throw new TypeError('TypeError: Symbol is not a constructor');
      symbol = create(HiddenSymbol.prototype);
      description = description === undefined ? '' : String(description);
      return defineProperties(symbol, {
        __description__: d('', description),
        __name__: d('', generateName(description))
      });
    };
    defineProperties(SymbolPolyfill, {
      for: d(function (key) {
        if (globalSymbols[key])
          return globalSymbols[key];
        return globalSymbols[key] = SymbolPolyfill(String(key));
      }),
      keyFor: d(function (s) {
        var key;
        validateSymbol(s);
        for (key in globalSymbols)
          if (globalSymbols[key] === s)
            return key;
      }),
      hasInstance: d('', NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill('hasInstance')),
      isConcatSpreadable: d('', NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill('isConcatSpreadable')),
      iterator: d('', NativeSymbol && NativeSymbol.iterator || SymbolPolyfill('iterator')),
      match: d('', NativeSymbol && NativeSymbol.match || SymbolPolyfill('match')),
      replace: d('', NativeSymbol && NativeSymbol.replace || SymbolPolyfill('replace')),
      search: d('', NativeSymbol && NativeSymbol.search || SymbolPolyfill('search')),
      species: d('', NativeSymbol && NativeSymbol.species || SymbolPolyfill('species')),
      split: d('', NativeSymbol && NativeSymbol.split || SymbolPolyfill('split')),
      toPrimitive: d('', NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill('toPrimitive')),
      toStringTag: d('', NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill('toStringTag')),
      unscopables: d('', NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill('unscopables'))
    });
    defineProperties(HiddenSymbol.prototype, {
      constructor: d(SymbolPolyfill),
      toString: d('', function () {
        return this.__name__;
      })
    });
    defineProperties(SymbolPolyfill.prototype, {
      toString: d(function () {
        return 'Symbol (' + validateSymbol(this).__description__ + ')';
      }),
      valueOf: d(function () {
        return validateSymbol(this);
      })
    });
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
      return validateSymbol(this);
    }));
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));
    defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag, d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));
    defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive, d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));
  });
  require.define('/node_modules/es6-iterator/node_modules/es6-symbol/validate-symbol.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var isSymbol = require('/node_modules/es6-iterator/node_modules/es6-symbol/is-symbol.js', module);
    module.exports = function (value) {
      if (!isSymbol(value))
        throw new TypeError(value + ' is not a symbol');
      return value;
    };
  });
  require.define('/node_modules/es6-iterator/node_modules/es6-symbol/is-symbol.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function (x) {
      return x && (typeof x === 'symbol' || x['@@toStringTag'] === 'Symbol') || false;
    };
  });
  require.define('/node_modules/es6-iterator/node_modules/es6-symbol/is-implemented.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function () {
      var symbol;
      if (typeof Symbol !== 'function')
        return false;
      symbol = Symbol('test symbol');
      try {
        String(symbol);
      } catch (e) {
        return false;
      }
      if (typeof Symbol.iterator === 'symbol')
        return true;
      if (typeof Symbol.isConcatSpreadable !== 'object')
        return false;
      if (typeof Symbol.iterator !== 'object')
        return false;
      if (typeof Symbol.toPrimitive !== 'object')
        return false;
      if (typeof Symbol.toStringTag !== 'object')
        return false;
      if (typeof Symbol.unscopables !== 'object')
        return false;
      return true;
    };
  });
  require.define('/node_modules/d/auto-bind.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var copy = require('/node_modules/es5-ext/object/copy.js', module), map = require('/node_modules/es5-ext/object/map.js', module), callable = require('/node_modules/es5-ext/object/valid-callable.js', module), validValue = require('/node_modules/es5-ext/object/valid-value.js', module), bind = Function.prototype.bind, defineProperty = Object.defineProperty, hasOwnProperty = Object.prototype.hasOwnProperty, define;
    define = function (name, desc, bindTo) {
      var value = validValue(desc) && callable(desc.value), dgs;
      dgs = copy(desc);
      delete dgs.writable;
      delete dgs.value;
      dgs.get = function () {
        if (hasOwnProperty.call(this, name))
          return value;
        desc.value = bind.call(value, bindTo == null ? this : this[bindTo]);
        defineProperty(this, name, desc);
        return this[name];
      };
      return dgs;
    };
    module.exports = function (props) {
      var bindTo = arguments[1];
      return map(props, function (desc, name) {
        return define(name, desc, bindTo);
      });
    };
  });
  require.define('/node_modules/es5-ext/object/valid-callable.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function (fn) {
      if (typeof fn !== 'function')
        throw new TypeError(fn + ' is not a function');
      return fn;
    };
  });
  require.define('/node_modules/es5-ext/object/map.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var callable = require('/node_modules/es5-ext/object/valid-callable.js', module), forEach = require('/node_modules/es5-ext/object/for-each.js', module), call = Function.prototype.call;
    module.exports = function (obj, cb) {
      var o = {}, thisArg = arguments[2];
      callable(cb);
      forEach(obj, function (value, key, obj, index) {
        o[key] = call.call(cb, thisArg, value, key, obj, index);
      });
      return o;
    };
  });
  require.define('/node_modules/es5-ext/object/for-each.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = require('/node_modules/es5-ext/object/_iterate.js', module)('forEach');
  });
  require.define('/node_modules/es5-ext/object/_iterate.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var callable = require('/node_modules/es5-ext/object/valid-callable.js', module), value = require('/node_modules/es5-ext/object/valid-value.js', module), bind = Function.prototype.bind, call = Function.prototype.call, keys = Object.keys, propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
    module.exports = function (method, defVal) {
      return function (obj, cb) {
        var list, thisArg = arguments[2], compareFn = arguments[3];
        obj = Object(value(obj));
        callable(cb);
        list = keys(obj);
        if (compareFn) {
          list.sort(typeof compareFn === 'function' ? bind.call(compareFn, obj) : undefined);
        }
        if (typeof method !== 'function')
          method = list[method];
        return call.call(method, list, function (key, index) {
          if (!propertyIsEnumerable.call(obj, key))
            return defVal;
          return call.call(cb, thisArg, obj[key], key, obj, index);
        });
      };
    };
  });
  require.define('/node_modules/es5-ext/object/copy.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var assign = require('/node_modules/es5-ext/object/assign/index.js', module), value = require('/node_modules/es5-ext/object/valid-value.js', module);
    module.exports = function (obj) {
      var copy = Object(value(obj));
      if (copy !== obj)
        return copy;
      return assign({}, obj);
    };
  });
  require.define('/node_modules/es5-ext/array/#/clear.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var value = require('/node_modules/es5-ext/object/valid-value.js', module);
    module.exports = function () {
      value(this).length = 0;
      return this;
    };
  });
  require.define('/node_modules/es5-ext/object/set-prototype-of/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = require('/node_modules/es5-ext/object/set-prototype-of/is-implemented.js', module)() ? Object.setPrototypeOf : require('/node_modules/es5-ext/object/set-prototype-of/shim.js', module);
  });
  require.define('/node_modules/es5-ext/object/set-prototype-of/shim.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var isObject = require('/node_modules/es5-ext/object/is-object.js', module), value = require('/node_modules/es5-ext/object/valid-value.js', module), isPrototypeOf = Object.prototype.isPrototypeOf, defineProperty = Object.defineProperty, nullDesc = {
        configurable: true,
        enumerable: false,
        writable: true,
        value: undefined
      }, validate;
    validate = function (obj, prototype) {
      value(obj);
      if (prototype === null || isObject(prototype))
        return obj;
      throw new TypeError('Prototype must be null or an object');
    };
    module.exports = function (status) {
      var fn, set;
      if (!status)
        return null;
      if (status.level === 2) {
        if (status.set) {
          set = status.set;
          fn = function (obj, prototype) {
            set.call(validate(obj, prototype), prototype);
            return obj;
          };
        } else {
          fn = function (obj, prototype) {
            validate(obj, prototype).__proto__ = prototype;
            return obj;
          };
        }
      } else {
        fn = function self(obj, prototype) {
          var isNullBase;
          validate(obj, prototype);
          isNullBase = isPrototypeOf.call(self.nullPolyfill, obj);
          if (isNullBase)
            delete self.nullPolyfill.__proto__;
          if (prototype === null)
            prototype = self.nullPolyfill;
          obj.__proto__ = prototype;
          if (isNullBase)
            defineProperty(self.nullPolyfill, '__proto__', nullDesc);
          return obj;
        };
      }
      return Object.defineProperty(fn, 'level', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: status.level
      });
    }(function () {
      var x = Object.create(null), y = {}, set, desc = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');
      if (desc) {
        try {
          set = desc.set;
          set.call(x, y);
        } catch (ignore) {
        }
        if (Object.getPrototypeOf(x) === y)
          return {
            set: set,
            level: 2
          };
      }
      x.__proto__ = y;
      if (Object.getPrototypeOf(x) === y)
        return { level: 2 };
      x = {};
      x.__proto__ = y;
      if (Object.getPrototypeOf(x) === y)
        return { level: 1 };
      return false;
    }());
    require('/node_modules/es5-ext/object/create.js', module);
  });
  require.define('/node_modules/es5-ext/object/create.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var create = Object.create, shim;
    if (!require('/node_modules/es5-ext/object/set-prototype-of/is-implemented.js', module)()) {
      shim = require('/node_modules/es5-ext/object/set-prototype-of/shim.js', module);
    }
    module.exports = function () {
      var nullObject, props, desc;
      if (!shim)
        return create;
      if (shim.level !== 1)
        return create;
      nullObject = {};
      props = {};
      desc = {
        configurable: false,
        enumerable: false,
        writable: true,
        value: undefined
      };
      Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
        if (name === '__proto__') {
          props[name] = {
            configurable: true,
            enumerable: false,
            writable: true,
            value: undefined
          };
          return;
        }
        props[name] = desc;
      });
      Object.defineProperties(nullObject, props);
      Object.defineProperty(shim, 'nullPolyfill', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: nullObject
      });
      return function (prototype, props) {
        return create(prototype === null ? nullObject : prototype, props);
      };
    }();
  });
  require.define('/node_modules/es5-ext/object/set-prototype-of/is-implemented.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var create = Object.create, getPrototypeOf = Object.getPrototypeOf, x = {};
    module.exports = function () {
      var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
      if (typeof setPrototypeOf !== 'function')
        return false;
      return getPrototypeOf(setPrototypeOf(customCreate(null), x)) === x;
    };
  });
  require.define('/node_modules/es5-ext/object/is-object.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var map = {
        function: true,
        object: true
      };
    module.exports = function (x) {
      return x != null && map[typeof x] || false;
    };
  });
  require.define('/node_modules/es6-iterator/for-of.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var isArguments = require('/node_modules/es5-ext/function/is-arguments.js', module), callable = require('/node_modules/es5-ext/object/valid-callable.js', module), isString = require('/node_modules/es5-ext/string/is-string.js', module), get = require('/node_modules/es6-iterator/get.js', module), isArray = Array.isArray, call = Function.prototype.call, some = Array.prototype.some;
    module.exports = function (iterable, cb) {
      var mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;
      if (isArray(iterable) || isArguments(iterable))
        mode = 'array';
      else if (isString(iterable))
        mode = 'string';
      else
        iterable = get(iterable);
      callable(cb);
      doBreak = function () {
        broken = true;
      };
      if (mode === 'array') {
        some.call(iterable, function (value) {
          call.call(cb, thisArg, value, doBreak);
          if (broken)
            return true;
        });
        return;
      }
      if (mode === 'string') {
        l = iterable.length;
        for (i = 0; i < l; ++i) {
          char = iterable[i];
          if (i + 1 < l) {
            code = char.charCodeAt(0);
            if (code >= 55296 && code <= 56319)
              char += iterable[++i];
          }
          call.call(cb, thisArg, char, doBreak);
          if (broken)
            break;
        }
        return;
      }
      result = iterable.next();
      while (!result.done) {
        call.call(cb, thisArg, result.value, doBreak);
        if (broken)
          return;
        result = iterable.next();
      }
    };
  });
  require.define('/node_modules/es6-iterator/get.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var isArguments = require('/node_modules/es5-ext/function/is-arguments.js', module), isString = require('/node_modules/es5-ext/string/is-string.js', module), ArrayIterator = require('/node_modules/es6-iterator/array.js', module), StringIterator = require('/node_modules/es6-iterator/string.js', module), iterable = require('/node_modules/es6-iterator/valid-iterable.js', module), iteratorSymbol = require('/node_modules/es6-iterator/node_modules/es6-symbol/index.js', module).iterator;
    module.exports = function (obj) {
      if (typeof iterable(obj)[iteratorSymbol] === 'function')
        return obj[iteratorSymbol]();
      if (isArguments(obj))
        return new ArrayIterator(obj);
      if (isString(obj))
        return new StringIterator(obj);
      return new ArrayIterator(obj);
    };
  });
  require.define('/node_modules/es6-iterator/valid-iterable.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var isIterable = require('/node_modules/es6-iterator/is-iterable.js', module);
    module.exports = function (value) {
      if (!isIterable(value))
        throw new TypeError(value + ' is not iterable');
      return value;
    };
  });
  require.define('/node_modules/es6-iterator/is-iterable.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var isArguments = require('/node_modules/es5-ext/function/is-arguments.js', module), isString = require('/node_modules/es5-ext/string/is-string.js', module), iteratorSymbol = require('/node_modules/es6-iterator/node_modules/es6-symbol/index.js', module).iterator, isArray = Array.isArray;
    module.exports = function (value) {
      if (value == null)
        return false;
      if (isArray(value))
        return true;
      if (isString(value))
        return true;
      if (isArguments(value))
        return true;
      return typeof value[iteratorSymbol] === 'function';
    };
  });
  require.define('/node_modules/es5-ext/string/is-string.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var toString = Object.prototype.toString, id = toString.call('');
    module.exports = function (x) {
      return typeof x === 'string' || x && typeof x === 'object' && (x instanceof String || toString.call(x) === id) || false;
    };
  });
  require.define('/node_modules/es5-ext/function/is-arguments.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var toString = Object.prototype.toString, id = toString.call(function () {
        return arguments;
      }());
    module.exports = function (x) {
      return toString.call(x) === id;
    };
  });
  require.define('/node_modules/es6-iterator/string.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var setPrototypeOf = require('/node_modules/es5-ext/object/set-prototype-of/index.js', module), d = require('/node_modules/d/index.js', module), Iterator = require('/node_modules/es6-iterator/index.js', module), defineProperty = Object.defineProperty, StringIterator;
    StringIterator = module.exports = function (str) {
      if (!(this instanceof StringIterator))
        return new StringIterator(str);
      str = String(str);
      Iterator.call(this, str);
      defineProperty(this, '__length__', d('', str.length));
    };
    if (setPrototypeOf)
      setPrototypeOf(StringIterator, Iterator);
    StringIterator.prototype = Object.create(Iterator.prototype, {
      constructor: d(StringIterator),
      _next: d(function () {
        if (!this.__list__)
          return;
        if (this.__nextIndex__ < this.__length__)
          return this.__nextIndex__++;
        this._unBind();
      }),
      _resolve: d(function (i) {
        var char = this.__list__[i], code;
        if (this.__nextIndex__ === this.__length__)
          return char;
        code = char.charCodeAt(0);
        if (code >= 55296 && code <= 56319)
          return char + this.__list__[this.__nextIndex__++];
        return char;
      }),
      toString: d(function () {
        return '[object String Iterator]';
      })
    });
  });
  require.define('/node_modules/es6-iterator/array.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var setPrototypeOf = require('/node_modules/es5-ext/object/set-prototype-of/index.js', module), contains = require('/node_modules/es5-ext/string/#/contains/index.js', module), d = require('/node_modules/d/index.js', module), Iterator = require('/node_modules/es6-iterator/index.js', module), defineProperty = Object.defineProperty, ArrayIterator;
    ArrayIterator = module.exports = function (arr, kind) {
      if (!(this instanceof ArrayIterator))
        return new ArrayIterator(arr, kind);
      Iterator.call(this, arr);
      if (!kind)
        kind = 'value';
      else if (contains.call(kind, 'key+value'))
        kind = 'key+value';
      else if (contains.call(kind, 'key'))
        kind = 'key';
      else
        kind = 'value';
      defineProperty(this, '__kind__', d('', kind));
    };
    if (setPrototypeOf)
      setPrototypeOf(ArrayIterator, Iterator);
    ArrayIterator.prototype = Object.create(Iterator.prototype, {
      constructor: d(ArrayIterator),
      _resolve: d(function (i) {
        if (this.__kind__ === 'value')
          return this.__list__[i];
        if (this.__kind__ === 'key+value')
          return [
            i,
            this.__list__[i]
          ];
        return i;
      }),
      toString: d(function () {
        return '[object Array Iterator]';
      })
    });
  });
  require.define('/node_modules/event-emitter/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var d = require('/node_modules/d/index.js', module), callable = require('/node_modules/es5-ext/object/valid-callable.js', module), apply = Function.prototype.apply, call = Function.prototype.call, create = Object.create, defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, hasOwnProperty = Object.prototype.hasOwnProperty, descriptor = {
        configurable: true,
        enumerable: false,
        writable: true
      }, on, once, off, emit, methods, descriptors, base;
    on = function (type, listener) {
      var data;
      callable(listener);
      if (!hasOwnProperty.call(this, '__ee__')) {
        data = descriptor.value = create(null);
        defineProperty(this, '__ee__', descriptor);
        descriptor.value = null;
      } else {
        data = this.__ee__;
      }
      if (!data[type])
        data[type] = listener;
      else if (typeof data[type] === 'object')
        data[type].push(listener);
      else
        data[type] = [
          data[type],
          listener
        ];
      return this;
    };
    once = function (type, listener) {
      var once, self;
      callable(listener);
      self = this;
      on.call(this, type, once = function () {
        off.call(self, type, once);
        apply.call(listener, this, arguments);
      });
      once.__eeOnceListener__ = listener;
      return this;
    };
    off = function (type, listener) {
      var data, listeners, candidate, i;
      callable(listener);
      if (!hasOwnProperty.call(this, '__ee__'))
        return this;
      data = this.__ee__;
      if (!data[type])
        return this;
      listeners = data[type];
      if (typeof listeners === 'object') {
        for (i = 0; candidate = listeners[i]; ++i) {
          if (candidate === listener || candidate.__eeOnceListener__ === listener) {
            if (listeners.length === 2)
              data[type] = listeners[i ? 0 : 1];
            else
              listeners.splice(i, 1);
          }
        }
      } else {
        if (listeners === listener || listeners.__eeOnceListener__ === listener) {
          delete data[type];
        }
      }
      return this;
    };
    emit = function (type) {
      var i, l, listener, listeners, args;
      if (!hasOwnProperty.call(this, '__ee__'))
        return;
      listeners = this.__ee__[type];
      if (!listeners)
        return;
      if (typeof listeners === 'object') {
        l = arguments.length;
        args = new Array(l - 1);
        for (i = 1; i < l; ++i)
          args[i - 1] = arguments[i];
        listeners = listeners.slice();
        for (i = 0; listener = listeners[i]; ++i) {
          apply.call(listener, this, args);
        }
      } else {
        switch (arguments.length) {
        case 1:
          call.call(listeners, this);
          break;
        case 2:
          call.call(listeners, this, arguments[1]);
          break;
        case 3:
          call.call(listeners, this, arguments[1], arguments[2]);
          break;
        default:
          l = arguments.length;
          args = new Array(l - 1);
          for (i = 1; i < l; ++i) {
            args[i - 1] = arguments[i];
          }
          apply.call(listeners, this, args);
        }
      }
    };
    methods = {
      on: on,
      once: once,
      off: off,
      emit: emit
    };
    descriptors = {
      on: d(on),
      once: d(once),
      off: d(off),
      emit: d(emit)
    };
    base = defineProperties({}, descriptors);
    module.exports = exports = function (o) {
      return o == null ? create(base) : defineProperties(Object(o), descriptors);
    };
    exports.methods = methods;
  });
  require.define('/node_modules/es5-ext/array/#/e-index-of.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var toPosInt = require('/node_modules/es5-ext/number/to-pos-integer.js', module), value = require('/node_modules/es5-ext/object/valid-value.js', module), indexOf = Array.prototype.indexOf, hasOwnProperty = Object.prototype.hasOwnProperty, abs = Math.abs, floor = Math.floor;
    module.exports = function (searchElement) {
      var i, l, fromIndex, val;
      if (searchElement === searchElement) {
        return indexOf.apply(this, arguments);
      }
      l = toPosInt(value(this).length);
      fromIndex = arguments[1];
      if (isNaN(fromIndex))
        fromIndex = 0;
      else if (fromIndex >= 0)
        fromIndex = floor(fromIndex);
      else
        fromIndex = toPosInt(this.length) - floor(abs(fromIndex));
      for (i = fromIndex; i < l; ++i) {
        if (hasOwnProperty.call(this, i)) {
          val = this[i];
          if (val !== val)
            return i;
        }
      }
      return -1;
    };
  });
  require.define('/node_modules/es5-ext/number/to-pos-integer.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var toInteger = require('/node_modules/es5-ext/number/to-integer.js', module), max = Math.max;
    module.exports = function (value) {
      return max(0, toInteger(value));
    };
  });
  require.define('/node_modules/es5-ext/number/to-integer.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var sign = require('/node_modules/es5-ext/math/sign/index.js', module), abs = Math.abs, floor = Math.floor;
    module.exports = function (value) {
      if (isNaN(value))
        return 0;
      value = Number(value);
      if (value === 0 || !isFinite(value))
        return value;
      return sign(value) * floor(abs(value));
    };
  });
  require.define('/node_modules/es5-ext/math/sign/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = require('/node_modules/es5-ext/math/sign/is-implemented.js', module)() ? Math.sign : require('/node_modules/es5-ext/math/sign/shim.js', module);
  });
  require.define('/node_modules/es5-ext/math/sign/shim.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function (value) {
      value = Number(value);
      if (isNaN(value) || value === 0)
        return value;
      return value > 0 ? 1 : -1;
    };
  });
  require.define('/node_modules/es5-ext/math/sign/is-implemented.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function () {
      var sign = Math.sign;
      if (typeof sign !== 'function')
        return false;
      return sign(10) === 1 && sign(-20) === -1;
    };
  });
  require.define('/node_modules/es6-map/is-implemented.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = function () {
      var map, iterator, result;
      if (typeof Map !== 'function')
        return false;
      try {
        map = new Map([
          [
            'raz',
            'one'
          ],
          [
            'dwa',
            'two'
          ],
          [
            'trzy',
            'three'
          ]
        ]);
      } catch (e) {
        return false;
      }
      if (String(map) !== '[object Map]')
        return false;
      if (map.size !== 3)
        return false;
      if (typeof map.clear !== 'function')
        return false;
      if (typeof map.delete !== 'function')
        return false;
      if (typeof map.entries !== 'function')
        return false;
      if (typeof map.forEach !== 'function')
        return false;
      if (typeof map.get !== 'function')
        return false;
      if (typeof map.has !== 'function')
        return false;
      if (typeof map.keys !== 'function')
        return false;
      if (typeof map.set !== 'function')
        return false;
      if (typeof map.values !== 'function')
        return false;
      iterator = map.entries();
      result = iterator.next();
      if (result.done !== false)
        return false;
      if (!result.value)
        return false;
      if (result.value[0] !== 'raz')
        return false;
      if (result.value[1] !== 'one')
        return false;
      return true;
    };
  });
  require.define('/dist/scope-analyzer.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
    var _get = function get(object, property, receiver) {
      if (object === null)
        object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          return get(parent, property, receiver);
        }
      } else if ('value' in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    };
    Object.defineProperty(exports, '__esModule', { value: true });
    var _multimap = require('/node_modules/multimap/index.js', module);
    var _MultiMap = _interopRequireWildcard(_multimap);
    var _shiftReducer = require('/node_modules/shift-reducer/dist/index.js', module);
    var _shiftReducer2 = _interopRequireDefault(_shiftReducer);
    var _scopeState = require('/dist/scope-state.js', module);
    var _scopeState2 = _interopRequireDefault(_scopeState);
    var _reference = require('/dist/reference.js', module);
    var _declaration = require('/dist/declaration.js', module);
    var _scope = require('/dist/scope.js', module);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== 'function' && superClass !== null) {
        throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var MultiMap = _MultiMap.default;
    var reduce = _shiftReducer2.default.default;
    function finishFunction(fnNode, params, body) {
      var isArrowFn = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
      var fnType = isArrowFn ? _scope.ScopeType.ARROW_FUNCTION : _scope.ScopeType.FUNCTION;
      if (params.hasParameterExpressions) {
        return params.withoutParameterExpressions().concat(body.finish(fnNode, fnType, !isArrowFn)).finish(fnNode, _scope.ScopeType.PARAMETERS);
      } else {
        return params.concat(body).finish(fnNode, fnType, !isArrowFn);
      }
    }
    function getFunctionDeclarations(statements) {
      return statements.filter(function (s) {
        return s.type === 'FunctionDeclaration';
      }).map(function (f) {
        return f.name;
      });
    }
    var ScopeAnalyzer = function (_MonoidalReducer) {
        _inherits(ScopeAnalyzer, _MonoidalReducer);
        function ScopeAnalyzer() {
          _classCallCheck(this, ScopeAnalyzer);
          return _possibleConstructorReturn(this, Object.getPrototypeOf(ScopeAnalyzer).call(this, _scopeState2.default));
        }
        _createClass(ScopeAnalyzer, [
          {
            key: 'reduceArrowExpression',
            value: function reduceArrowExpression(node, _ref) {
              var params = _ref.params;
              var body = _ref.body;
              return finishFunction(node, params, body, true);
            }
          },
          {
            key: 'reduceAssignmentExpression',
            value: function reduceAssignmentExpression(node, _ref2) {
              var binding = _ref2.binding;
              var expression = _ref2.expression;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceAssignmentExpression', this).call(this, node, {
                binding: binding.addReferences(_reference.Accessibility.WRITE),
                expression: expression
              });
            }
          },
          {
            key: 'reduceBindingIdentifier',
            value: function reduceBindingIdentifier(node) {
              return new _scopeState2.default({ bindingsForParent: [node] });
            }
          },
          {
            key: 'reduceBindingPropertyIdentifier',
            value: function reduceBindingPropertyIdentifier(node, _ref3) {
              var binding = _ref3.binding;
              var init = _ref3.init;
              var s = _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceBindingPropertyIdentifier', this).call(this, node, {
                  binding: binding,
                  init: init
                });
              if (init) {
                return s.withParameterExpressions();
              }
              return s;
            }
          },
          {
            key: 'reduceBindingWithDefault',
            value: function reduceBindingWithDefault(node, _ref4) {
              var binding = _ref4.binding;
              var init = _ref4.init;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceBindingWithDefault', this).call(this, node, {
                binding: binding,
                init: init
              }).withParameterExpressions();
            }
          },
          {
            key: 'reduceBlock',
            value: function reduceBlock(node, _ref5) {
              var statements = _ref5.statements;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceBlock', this).call(this, node, { statements: statements }).withPotentialVarFunctions(getFunctionDeclarations(node.statements)).finish(node, _scope.ScopeType.BLOCK);
            }
          },
          {
            key: 'reduceCallExpression',
            value: function reduceCallExpression(node, _ref6) {
              var callee = _ref6.callee;
              var _arguments = _ref6.arguments;
              var s = _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceCallExpression', this).call(this, node, {
                  callee: callee,
                  arguments: _arguments
                });
              if (node.callee.type === 'IdentifierExpression' && node.callee.name === 'eval') {
                return s.taint();
              }
              return s;
            }
          },
          {
            key: 'reduceCatchClause',
            value: function reduceCatchClause(node, _ref7) {
              var binding = _ref7.binding;
              var body = _ref7.body;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceCatchClause', this).call(this, node, {
                binding: binding.addDeclarations(_declaration.DeclarationType.CATCH_PARAMETER),
                body: body
              }).finish(node, _scope.ScopeType.CATCH);
            }
          },
          {
            key: 'reduceClassDeclaration',
            value: function reduceClassDeclaration(node, _ref8) {
              var name = _ref8.name;
              var _super = _ref8.super;
              var elements = _ref8.elements;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceClassDeclaration', this).call(this, node, {
                name: name.addDeclarations(_declaration.DeclarationType.CLASS_NAME),
                super: _super,
                elements: elements
              });
            }
          },
          {
            key: 'reduceClassExpression',
            value: function reduceClassExpression(node, _ref9) {
              var name = _ref9.name;
              var _super = _ref9.super;
              var elements = _ref9.elements;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceClassExpression', this).call(this, node, {
                name: name,
                super: _super,
                elements: elements
              }).addDeclarations(_declaration.DeclarationType.CLASS_NAME).finish(node, _scope.ScopeType.CLASS_NAME);
            }
          },
          {
            key: 'reduceCompoundAssignmentExpression',
            value: function reduceCompoundAssignmentExpression(node, _ref10) {
              var binding = _ref10.binding;
              var expression = _ref10.expression;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceCompoundAssignmentExpression', this).call(this, node, {
                binding: binding.addReferences(_reference.Accessibility.READWRITE),
                expression: expression
              });
            }
          },
          {
            key: 'reduceComputedMemberExpression',
            value: function reduceComputedMemberExpression(node, _ref11) {
              var object = _ref11.object;
              var expression = _ref11.expression;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceComputedMemberExpression', this).call(this, node, {
                object: object,
                expression: expression
              }).withParameterExpressions();
            }
          },
          {
            key: 'reduceForInStatement',
            value: function reduceForInStatement(node, _ref12) {
              var left = _ref12.left;
              var right = _ref12.right;
              var body = _ref12.body;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceForInStatement', this).call(this, node, {
                left: left.addReferences(_reference.Accessibility.WRITE),
                right: right,
                body: body
              }).finish(node, _scope.ScopeType.BLOCK);
            }
          },
          {
            key: 'reduceForOfStatement',
            value: function reduceForOfStatement(node, _ref13) {
              var left = _ref13.left;
              var right = _ref13.right;
              var body = _ref13.body;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceForOfStatement', this).call(this, node, {
                left: left.addReferences(_reference.Accessibility.WRITE),
                right: right,
                body: body
              }).finish(node, _scope.ScopeType.BLOCK);
            }
          },
          {
            key: 'reduceForStatement',
            value: function reduceForStatement(node, _ref14) {
              var init = _ref14.init;
              var test = _ref14.test;
              var update = _ref14.update;
              var body = _ref14.body;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceForStatement', this).call(this, node, {
                init: init ? init.withoutBindingsForParent() : init,
                test: test,
                update: update,
                body: body
              }).finish(node, _scope.ScopeType.BLOCK);
            }
          },
          {
            key: 'reduceFormalParameters',
            value: function reduceFormalParameters(node, _ref15) {
              var items = _ref15.items;
              var rest = _ref15.rest;
              var s = rest ? rest : new _scopeState2.default;
              items.forEach(function (item, ind) {
                return s = s.concat(item.hasParameterExpressions ? item.finish(node.items[ind], _scope.ScopeType.PARAMETER_EXPRESSION) : item);
              });
              return s.addDeclarations(_declaration.DeclarationType.PARAMETER);
            }
          },
          {
            key: 'reduceFunctionDeclaration',
            value: function reduceFunctionDeclaration(node, _ref16) {
              var name = _ref16.name;
              var params = _ref16.params;
              var body = _ref16.body;
              return name.concat(finishFunction(node, params, body)).addFunctionDeclaration();
            }
          },
          {
            key: 'reduceFunctionExpression',
            value: function reduceFunctionExpression(node, _ref17) {
              var name = _ref17.name;
              var params = _ref17.params;
              var body = _ref17.body;
              var s = finishFunction(node, params, body);
              if (name) {
                return name.concat(s).addDeclarations(_declaration.DeclarationType.FUNCTION_NAME).finish(node, _scope.ScopeType.FUNCTION_NAME);
              }
              return s;
            }
          },
          {
            key: 'reduceGetter',
            value: function reduceGetter(node, _ref18) {
              var name = _ref18.name;
              var body = _ref18.body;
              return name.concat(body.finish(node, _scope.ScopeType.FUNCTION, true));
            }
          },
          {
            key: 'reduceIdentifierExpression',
            value: function reduceIdentifierExpression(node) {
              return new _scopeState2.default({
                freeIdentifiers: new MultiMap([[
                    node.name,
                    new _reference.ReadReference(node)
                  ]])
              });
            }
          },
          {
            key: 'reduceIfStatement',
            value: function reduceIfStatement(node, _ref19) {
              var test = _ref19.test;
              var consequent = _ref19.consequent;
              var alternate = _ref19.alternate;
              var pvsfd = [];
              if (node.consequent.type === 'FunctionDeclaration') {
                pvsfd.push(node.consequent.name);
              }
              if (node.alternate && node.alternate.type === 'FunctionDeclaration') {
                pvsfd.push(node.alternate.name);
              }
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceIfStatement', this).call(this, node, {
                test: test,
                consequent: consequent,
                alternate: alternate
              }).withPotentialVarFunctions(pvsfd);
            }
          },
          {
            key: 'reduceMethod',
            value: function reduceMethod(node, _ref20) {
              var name = _ref20.name;
              var params = _ref20.params;
              var body = _ref20.body;
              return name.concat(finishFunction(node, params, body));
            }
          },
          {
            key: 'reduceModule',
            value: function reduceModule(node, _ref21) {
              var directives = _ref21.directives;
              var items = _ref21.items;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceModule', this).call(this, node, {
                directives: directives,
                items: items
              }).finish(node, _scope.ScopeType.MODULE);
            }
          },
          {
            key: 'reduceScript',
            value: function reduceScript(node, _ref22) {
              var directives = _ref22.directives;
              var statements = _ref22.statements;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceScript', this).call(this, node, {
                directives: directives,
                statements: statements
              }).finish(node, _scope.ScopeType.SCRIPT);
            }
          },
          {
            key: 'reduceSetter',
            value: function reduceSetter(node, _ref23) {
              var name = _ref23.name;
              var param = _ref23.param;
              var body = _ref23.body;
              if (param.hasParameterExpressions) {
                param = param.finish(node, _scope.ScopeType.PARAMETER_EXPRESSION);
              }
              return name.concat(finishFunction(node, param.addDeclarations(_declaration.DeclarationType.PARAMETER), body));
            }
          },
          {
            key: 'reduceSwitchCase',
            value: function reduceSwitchCase(node, _ref24) {
              var test = _ref24.test;
              var consequent = _ref24.consequent;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceSwitchCase', this).call(this, node, {
                test: test,
                consequent: consequent
              }).finish(node, _scope.ScopeType.BLOCK).withPotentialVarFunctions(getFunctionDeclarations(node.consequent));
            }
          },
          {
            key: 'reduceSwitchDefault',
            value: function reduceSwitchDefault(node, _ref25) {
              var consequent = _ref25.consequent;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceSwitchDefault', this).call(this, node, { consequent: consequent }).finish(node, _scope.ScopeType.BLOCK).withPotentialVarFunctions(getFunctionDeclarations(node.consequent));
            }
          },
          {
            key: 'reduceUpdateExpression',
            value: function reduceUpdateExpression(node, _ref26) {
              var operand = _ref26.operand;
              return operand.addReferences(_reference.Accessibility.READWRITE);
            }
          },
          {
            key: 'reduceVariableDeclaration',
            value: function reduceVariableDeclaration(node, _ref27) {
              var declarators = _ref27.declarators;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceVariableDeclaration', this).call(this, node, { declarators: declarators }).addDeclarations(_declaration.DeclarationType.fromVarDeclKind(node.kind), true);
            }
          },
          {
            key: 'reduceVariableDeclarationStatement',
            value: function reduceVariableDeclarationStatement(node, _ref28) {
              var declaration = _ref28.declaration;
              return declaration.withoutBindingsForParent();
            }
          },
          {
            key: 'reduceVariableDeclarator',
            value: function reduceVariableDeclarator(node, _ref29) {
              var binding = _ref29.binding;
              var init = _ref29.init;
              var s = _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceVariableDeclarator', this).call(this, node, {
                  binding: binding,
                  init: init
                });
              if (init) {
                return s.addReferences(_reference.Accessibility.WRITE, true);
              }
              return s;
            }
          },
          {
            key: 'reduceWithStatement',
            value: function reduceWithStatement(node, _ref30) {
              var object = _ref30.object;
              var body = _ref30.body;
              return _get(Object.getPrototypeOf(ScopeAnalyzer.prototype), 'reduceWithStatement', this).call(this, node, {
                object: object,
                body: body.finish(node, _scope.ScopeType.WITH)
              });
            }
          }
        ], [{
            key: 'analyze',
            value: function analyze(program) {
              return reduce(new this, program).children[0];
            }
          }]);
        return ScopeAnalyzer;
      }(_shiftReducer.MonoidalReducer);
    exports.default = ScopeAnalyzer;
  });
  require.define('/dist/scope.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.GlobalScope = exports.Scope = exports.ScopeType = undefined;
    var _es6Map = require('/node_modules/es6-map/index.js', module);
    var _es6Map2 = _interopRequireDefault(_es6Map);
    var _variable = require('/dist/variable.js', module);
    var _variable2 = _interopRequireDefault(_variable);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== 'function' && superClass !== null) {
        throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    var ScopeType = exports.ScopeType = function ScopeType(name) {
        _classCallCheck(this, ScopeType);
        this.name = name;
      };
    ScopeType.GLOBAL = new ScopeType('global');
    ScopeType.MODULE = new ScopeType('module');
    ScopeType.SCRIPT = new ScopeType('script');
    ScopeType.ARROW_FUNCTION = new ScopeType('arrow function');
    ScopeType.FUNCTION = new ScopeType('function');
    ScopeType.FUNCTION_NAME = new ScopeType('function name');
    ScopeType.PARAMETERS = new ScopeType('parameters');
    ScopeType.PARAMETER_EXPRESSION = new ScopeType('parameter expression');
    ScopeType.WITH = new ScopeType('with');
    ScopeType.CATCH = new ScopeType('catch');
    ScopeType.BLOCK = new ScopeType('block');
    ScopeType.CLASS_NAME = new ScopeType('class name');
    var Scope = exports.Scope = function () {
        function Scope(children, variables, through, type, isDynamic, astNode) {
          var _this = this;
          _classCallCheck(this, Scope);
          this.children = children;
          this.through = through;
          this.type = type;
          this.astNode = astNode;
          this.variables = new _es6Map2.default;
          variables.forEach(function (v) {
            return _this.variables.set(v.name, v);
          });
          this.variableList = [];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;
          try {
            for (var _iterator = this.variables.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var x = _step.value;
              this.variableList.push(x);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          this.dynamic = isDynamic || type === ScopeType.WITH || type === ScopeType.GLOBAL;
        }
        _createClass(Scope, [
          {
            key: 'isGlobal',
            value: function isGlobal() {
              return this.type === ScopeType.GLOBAL;
            }
          },
          {
            key: 'lookupVariable',
            value: function lookupVariable(name) {
              return this.variables.get(name);
            }
          },
          {
            key: 'findVariables',
            value: function findVariables(identifier) {
            }
          }
        ]);
        return Scope;
      }();
    var GlobalScope = exports.GlobalScope = function (_Scope) {
        _inherits(GlobalScope, _Scope);
        function GlobalScope(children, variables, through, astNode) {
          _classCallCheck(this, GlobalScope);
          var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(GlobalScope).call(this, children, variables, through, ScopeType.GLOBAL, true, astNode));
          through.forEachEntry(function (v, k) {
            _this2.variables.set(k, new _variable2.default(k, v, []));
          });
          _this2.variableList = [];
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;
          try {
            for (var _iterator2 = _this2.variables.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var x = _step2.value;
              _this2.variableList.push(x);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          return _this2;
        }
        return GlobalScope;
      }(Scope);
  });
  require.define('/dist/variable.js', function (module, exports, __dirname, __filename) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    var Variable = function Variable(name, references, declarations) {
      _classCallCheck(this, Variable);
      this.name = name;
      this.references = references;
      this.declarations = declarations;
    };
    exports.default = Variable;
  });
  require.define('/node_modules/es6-map/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    module.exports = require('/node_modules/es6-map/is-implemented.js', module)() ? Map : require('/node_modules/es6-map/polyfill.js', module);
  });
  require.define('/dist/declaration.js', function (module, exports, __dirname, __filename) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== 'function' && superClass !== null) {
        throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    var DeclarationType = exports.DeclarationType = function DeclarationType(name, isBlockScoped) {
        _classCallCheck(this, DeclarationType);
        this.name = name;
        this.isBlockScoped = !!isBlockScoped;
        this.isFunctionScoped = !isBlockScoped;
      };
    var BlockScopedDeclaration = exports.BlockScopedDeclaration = function (_DeclarationType) {
        _inherits(BlockScopedDeclaration, _DeclarationType);
        function BlockScopedDeclaration(name) {
          _classCallCheck(this, BlockScopedDeclaration);
          return _possibleConstructorReturn(this, Object.getPrototypeOf(BlockScopedDeclaration).call(this, name, true));
        }
        return BlockScopedDeclaration;
      }(DeclarationType);
    var FunctionScopedDeclaration = exports.FunctionScopedDeclaration = function (_DeclarationType2) {
        _inherits(FunctionScopedDeclaration, _DeclarationType2);
        function FunctionScopedDeclaration(name) {
          _classCallCheck(this, FunctionScopedDeclaration);
          return _possibleConstructorReturn(this, Object.getPrototypeOf(FunctionScopedDeclaration).call(this, name, false));
        }
        return FunctionScopedDeclaration;
      }(DeclarationType);
    DeclarationType.VAR = new FunctionScopedDeclaration('var');
    DeclarationType.CONST = new BlockScopedDeclaration('const');
    DeclarationType.LET = new BlockScopedDeclaration('let');
    DeclarationType.FUNCTION_DECLARATION = new BlockScopedDeclaration('function declaration');
    DeclarationType.FUNCTION_NAME = new BlockScopedDeclaration('function name');
    DeclarationType.CLASS_NAME = new BlockScopedDeclaration('class name');
    DeclarationType.PARAMETER = new FunctionScopedDeclaration('parameter');
    DeclarationType.CATCH_PARAMETER = new BlockScopedDeclaration('catch parameter');
    DeclarationType.fromVarDeclKind = function (variableDeclarationKind) {
      switch (variableDeclarationKind) {
      case 'var':
        return DeclarationType.VAR;
      case 'const':
        return DeclarationType.CONST;
      case 'let':
        return DeclarationType.LET;
      default:
        throw new Error('Invalid VariableDeclarationKind: ' + JSON.stringify(variableDeclarationKind));
      }
    };
    var Declaration = exports.Declaration = function Declaration(node, type) {
        _classCallCheck(this, Declaration);
        this.node = node;
        this.type = type;
      };
    var VarDeclaration = exports.VarDeclaration = function (_Declaration) {
        _inherits(VarDeclaration, _Declaration);
        function VarDeclaration(node) {
          _classCallCheck(this, VarDeclaration);
          return _possibleConstructorReturn(this, Object.getPrototypeOf(VarDeclaration).call(this, node, DeclarationType.VAR));
        }
        return VarDeclaration;
      }(Declaration);
    var ConstDeclaration = exports.ConstDeclaration = function (_Declaration2) {
        _inherits(ConstDeclaration, _Declaration2);
        function ConstDeclaration(node) {
          _classCallCheck(this, ConstDeclaration);
          return _possibleConstructorReturn(this, Object.getPrototypeOf(ConstDeclaration).call(this, node, DeclarationType.CONST));
        }
        return ConstDeclaration;
      }(Declaration);
    var LetDeclaration = exports.LetDeclaration = function (_Declaration3) {
        _inherits(LetDeclaration, _Declaration3);
        function LetDeclaration(node) {
          _classCallCheck(this, LetDeclaration);
          return _possibleConstructorReturn(this, Object.getPrototypeOf(LetDeclaration).call(this, node, DeclarationType.LET));
        }
        return LetDeclaration;
      }(Declaration);
    var FunctionNameDeclaration = exports.FunctionNameDeclaration = function (_Declaration4) {
        _inherits(FunctionNameDeclaration, _Declaration4);
        function FunctionNameDeclaration(node) {
          _classCallCheck(this, FunctionNameDeclaration);
          return _possibleConstructorReturn(this, Object.getPrototypeOf(FunctionNameDeclaration).call(this, node, DeclarationType.FUNCTION_NAME));
        }
        return FunctionNameDeclaration;
      }(Declaration);
    var ParameterDeclaration = exports.ParameterDeclaration = function (_Declaration5) {
        _inherits(ParameterDeclaration, _Declaration5);
        function ParameterDeclaration(node) {
          _classCallCheck(this, ParameterDeclaration);
          return _possibleConstructorReturn(this, Object.getPrototypeOf(ParameterDeclaration).call(this, node, DeclarationType.PARAMETER));
        }
        return ParameterDeclaration;
      }(Declaration);
    var CatchDeclaration = exports.CatchDeclaration = function (_Declaration6) {
        _inherits(CatchDeclaration, _Declaration6);
        function CatchDeclaration(node) {
          _classCallCheck(this, CatchDeclaration);
          return _possibleConstructorReturn(this, Object.getPrototypeOf(CatchDeclaration).call(this, node, DeclarationType.CATCH));
        }
        return CatchDeclaration;
      }(Declaration);
  });
  require.define('/dist/reference.js', function (module, exports, __dirname, __filename) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== 'function' && superClass !== null) {
        throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    var Accessibility = exports.Accessibility = function Accessibility(isRead, isWrite) {
        _classCallCheck(this, Accessibility);
        this.isRead = !!isRead;
        this.isWrite = !!isWrite;
        this.isReadWrite = !!(isRead && isWrite);
      };
    Accessibility.READ = new Accessibility(true, false);
    Accessibility.WRITE = new Accessibility(false, true);
    Accessibility.READWRITE = new Accessibility(true, true);
    var Reference = exports.Reference = function Reference(node, accessibility) {
        _classCallCheck(this, Reference);
        this.node = node;
        this.accessibility = accessibility;
      };
    var ReadReference = exports.ReadReference = function (_Reference) {
        _inherits(ReadReference, _Reference);
        function ReadReference(node) {
          _classCallCheck(this, ReadReference);
          return _possibleConstructorReturn(this, Object.getPrototypeOf(ReadReference).call(this, node, Accessibility.READ));
        }
        return ReadReference;
      }(Reference);
    var WriteReference = exports.WriteReference = function (_Reference2) {
        _inherits(WriteReference, _Reference2);
        function WriteReference(node) {
          _classCallCheck(this, WriteReference);
          return _possibleConstructorReturn(this, Object.getPrototypeOf(WriteReference).call(this, node, Accessibility.WRITE));
        }
        return WriteReference;
      }(Reference);
    var ReadWriteReference = exports.ReadWriteReference = function (_Reference3) {
        _inherits(ReadWriteReference, _Reference3);
        function ReadWriteReference(node) {
          _classCallCheck(this, ReadWriteReference);
          return _possibleConstructorReturn(this, Object.getPrototypeOf(ReadWriteReference).call(this, node, Accessibility.READWRITE));
        }
        return ReadWriteReference;
      }(Reference);
  });
  require.define('/dist/scope-state.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
    Object.defineProperty(exports, '__esModule', { value: true });
    var _multimap = require('/node_modules/multimap/index.js', module);
    var _MultiMap = _interopRequireWildcard(_multimap);
    var _declaration = require('/dist/declaration.js', module);
    var _reference = require('/dist/reference.js', module);
    var _scope = require('/dist/scope.js', module);
    var _variable = require('/dist/variable.js', module);
    var _variable2 = _interopRequireDefault(_variable);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    var MultiMap = _MultiMap.default;
    function merge(multiMap, otherMultiMap) {
      otherMultiMap.forEachEntry(function (v, k) {
        multiMap.set.apply(multiMap, [k].concat(v));
      });
      return multiMap;
    }
    function resolveArguments(freeIdentifiers, variables) {
      var args = freeIdentifiers.get('arguments') || [];
      freeIdentifiers.delete('arguments');
      return variables.concat(new _variable2.default('arguments', args, []));
    }
    function resolveDeclarations(freeIdentifiers, decls, variables) {
      decls.forEachEntry(function (declarations, name) {
        var references = freeIdentifiers.get(name) || [];
        variables = variables.concat(new _variable2.default(name, references, declarations));
        freeIdentifiers.delete(name);
      });
      return variables;
    }
    var ScopeState = function () {
        function ScopeState() {
          var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
          var _ref$freeIdentifiers = _ref.freeIdentifiers;
          var freeIdentifiers = _ref$freeIdentifiers === undefined ? new MultiMap : _ref$freeIdentifiers;
          var _ref$functionScopedDe = _ref.functionScopedDeclarations;
          var functionScopedDeclarations = _ref$functionScopedDe === undefined ? new MultiMap : _ref$functionScopedDe;
          var _ref$blockScopedDecla = _ref.blockScopedDeclarations;
          var blockScopedDeclarations = _ref$blockScopedDecla === undefined ? new MultiMap : _ref$blockScopedDecla;
          var _ref$functionDeclarat = _ref.functionDeclarations;
          var functionDeclarations = _ref$functionDeclarat === undefined ? new MultiMap : _ref$functionDeclarat;
          var _ref$children = _ref.children;
          var children = _ref$children === undefined ? [] : _ref$children;
          var _ref$dynamic = _ref.dynamic;
          var dynamic = _ref$dynamic === undefined ? false : _ref$dynamic;
          var _ref$bindingsForParen = _ref.bindingsForParent;
          var bindingsForParent = _ref$bindingsForParen === undefined ? [] : _ref$bindingsForParen;
          var _ref$potentiallyVarSc = _ref.potentiallyVarScopedFunctionDeclarations;
          var potentiallyVarScopedFunctionDeclarations = _ref$potentiallyVarSc === undefined ? new MultiMap : _ref$potentiallyVarSc;
          var _ref$hasParameterExpr = _ref.hasParameterExpressions;
          var hasParameterExpressions = _ref$hasParameterExpr === undefined ? false : _ref$hasParameterExpr;
          _classCallCheck(this, ScopeState);
          this.freeIdentifiers = freeIdentifiers;
          this.functionScopedDeclarations = functionScopedDeclarations;
          this.blockScopedDeclarations = blockScopedDeclarations;
          this.functionDeclarations = functionDeclarations;
          this.children = children;
          this.dynamic = dynamic;
          this.bindingsForParent = bindingsForParent;
          this.potentiallyVarScopedFunctionDeclarations = potentiallyVarScopedFunctionDeclarations;
          this.hasParameterExpressions = hasParameterExpressions;
        }
        _createClass(ScopeState, [
          {
            key: 'concat',
            value: function concat(b) {
              if (this === b) {
                return this;
              }
              return new ScopeState({
                freeIdentifiers: merge(merge(new MultiMap, this.freeIdentifiers), b.freeIdentifiers),
                functionScopedDeclarations: merge(merge(new MultiMap, this.functionScopedDeclarations), b.functionScopedDeclarations),
                blockScopedDeclarations: merge(merge(new MultiMap, this.blockScopedDeclarations), b.blockScopedDeclarations),
                functionDeclarations: merge(merge(new MultiMap, this.functionDeclarations), b.functionDeclarations),
                children: this.children.concat(b.children),
                dynamic: this.dynamic || b.dynamic,
                bindingsForParent: this.bindingsForParent.concat(b.bindingsForParent),
                potentiallyVarScopedFunctionDeclarations: merge(merge(new MultiMap, this.potentiallyVarScopedFunctionDeclarations), b.potentiallyVarScopedFunctionDeclarations),
                hasParameterExpressions: this.hasParameterExpressions || b.hasParameterExpressions
              });
            }
          },
          {
            key: 'addDeclarations',
            value: function addDeclarations(kind) {
              var keepBindingsForParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
              var declMap = new MultiMap;
              merge(declMap, kind.isBlockScoped ? this.blockScopedDeclarations : this.functionScopedDeclarations);
              this.bindingsForParent.forEach(function (binding) {
                return declMap.set(binding.name, new _declaration.Declaration(binding, kind));
              });
              var s = new ScopeState(this);
              if (kind.isBlockScoped) {
                s.blockScopedDeclarations = declMap;
              } else {
                s.functionScopedDeclarations = declMap;
              }
              if (!keepBindingsForParent) {
                s.bindingsForParent = [];
              }
              return s;
            }
          },
          {
            key: 'addFunctionDeclaration',
            value: function addFunctionDeclaration() {
              var binding = this.bindingsForParent[0];
              var s = new ScopeState(this);
              merge(s.functionDeclarations, new MultiMap([[
                  binding.name,
                  new _declaration.Declaration(binding, _declaration.DeclarationType.FUNCTION_DECLARATION)
                ]]));
              s.bindingsForParent = [];
              return s;
            }
          },
          {
            key: 'addReferences',
            value: function addReferences(accessibility) {
              var keepBindingsForParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
              var freeMap = new MultiMap;
              merge(freeMap, this.freeIdentifiers);
              this.bindingsForParent.forEach(function (binding) {
                return freeMap.set(binding.name, new _reference.Reference(binding, accessibility));
              });
              var s = new ScopeState(this);
              s.freeIdentifiers = freeMap;
              if (!keepBindingsForParent) {
                s.bindingsForParent = [];
              }
              return s;
            }
          },
          {
            key: 'taint',
            value: function taint() {
              var s = new ScopeState(this);
              s.dynamic = true;
              return s;
            }
          },
          {
            key: 'withoutBindingsForParent',
            value: function withoutBindingsForParent() {
              var s = new ScopeState(this);
              s.bindingsForParent = [];
              return s;
            }
          },
          {
            key: 'withParameterExpressions',
            value: function withParameterExpressions() {
              var s = new ScopeState(this);
              s.hasParameterExpressions = true;
              return s;
            }
          },
          {
            key: 'withoutParameterExpressions',
            value: function withoutParameterExpressions() {
              var s = new ScopeState(this);
              s.hasParameterExpressions = false;
              return s;
            }
          },
          {
            key: 'withPotentialVarFunctions',
            value: function withPotentialVarFunctions(functions) {
              var pvsfd = merge(new MultiMap, this.potentiallyVarScopedFunctionDeclarations);
              functions.forEach(function (f) {
                return pvsfd.set(f.name, f);
              });
              var s = new ScopeState(this);
              s.potentiallyVarScopedFunctionDeclarations = pvsfd;
              return s;
            }
          },
          {
            key: 'finish',
            value: function finish(astNode, scopeType) {
              var shouldResolveArguments = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
              var variables = [];
              var functionScoped = new MultiMap;
              var freeIdentifiers = merge(new MultiMap, this.freeIdentifiers);
              var pvsfd = merge(new MultiMap, this.potentiallyVarScopedFunctionDeclarations);
              var children = this.children;
              this.blockScopedDeclarations.forEachEntry(function (v, k) {
                pvsfd.delete(k);
              });
              this.functionDeclarations.forEachEntry(function (v, k) {
                var existing = pvsfd.get(k);
                if (existing && (v.length > 1 || v[0].node !== existing)) {
                  pvsfd.delete(k);
                }
              });
              switch (scopeType) {
              case _scope.ScopeType.BLOCK:
              case _scope.ScopeType.CATCH:
              case _scope.ScopeType.WITH:
              case _scope.ScopeType.FUNCTION_NAME:
              case _scope.ScopeType.PARAMETER_EXPRESSION:
                variables = resolveDeclarations(freeIdentifiers, this.blockScopedDeclarations, variables);
                merge(functionScoped, this.functionScopedDeclarations);
                break;
              case _scope.ScopeType.PARAMETERS:
              case _scope.ScopeType.ARROW_FUNCTION:
              case _scope.ScopeType.FUNCTION:
              case _scope.ScopeType.MODULE:
              case _scope.ScopeType.SCRIPT:
                var declarations = new MultiMap;
                if (scopeType === _scope.ScopeType.SCRIPT) {
                  children = [new _scope.Scope(children, resolveDeclarations(freeIdentifiers, this.blockScopedDeclarations, []), freeIdentifiers, _scope.ScopeType.SCRIPT, this.dynamic, astNode)];
                } else {
                  merge(declarations, this.blockScopedDeclarations);
                }
                if (shouldResolveArguments) {
                  declarations.set('arguments');
                }
                merge(declarations, this.functionScopedDeclarations);
                merge(declarations, this.functionDeclarations);
                if (scopeType === _scope.ScopeType.ARROW_FUNCTION || scopeType === _scope.ScopeType.FUNCTION) {
                  merge(declarations, pvsfd);
                }
                pvsfd = new MultiMap;
                variables = resolveDeclarations(freeIdentifiers, declarations, variables);
                if (scopeType === _scope.ScopeType.MODULE) {
                  children = [new _scope.Scope(children, variables, freeIdentifiers, _scope.ScopeType.MODULE, this.dynamic, astNode)];
                  variables = [];
                }
                break;
              default:
                throw new Error('not reached');
              }
              var scope = scopeType === _scope.ScopeType.SCRIPT || scopeType === _scope.ScopeType.MODULE ? new _scope.GlobalScope(children, variables, freeIdentifiers, astNode) : new _scope.Scope(children, variables, freeIdentifiers, scopeType, this.dynamic, astNode);
              return new ScopeState({
                freeIdentifiers: freeIdentifiers,
                functionScopedDeclarations: functionScoped,
                children: [scope],
                bindingsForParent: this.bindingsForParent,
                potentiallyVarScopedFunctionDeclarations: pvsfd,
                hasParameterExpressions: this.hasParameterExpressions
              });
            }
          }
        ], [{
            key: 'empty',
            value: function empty() {
              return new ScopeState({});
            }
          }]);
        return ScopeState;
      }();
    exports.default = ScopeState;
  });
  require.define('/node_modules/multimap/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var Multimap = function () {
        var mapCtor;
        if (typeof Map !== 'undefined') {
          mapCtor = Map;
        }
        function Multimap(iterable) {
          var self = this;
          self._map = mapCtor;
          if (Multimap.Map) {
            self._map = Multimap.Map;
          }
          self._ = self._map ? new self._map : {};
          if (iterable) {
            iterable.forEach(function (i) {
              self.set(i[0], i[1]);
            });
          }
        }
        Multimap.prototype.get = function (key) {
          return this._map ? this._.get(key) : this._[key];
        };
        Multimap.prototype.set = function (key, val) {
          var args = Array.prototype.slice.call(arguments);
          key = args.shift();
          var entry = this.get(key);
          if (!entry) {
            entry = [];
            if (this._map)
              this._.set(key, entry);
            else
              this._[key] = entry;
          }
          Array.prototype.push.apply(entry, args);
          return this;
        };
        Multimap.prototype.delete = function (key, val) {
          if (!this.has(key))
            return false;
          if (arguments.length == 1) {
            this._map ? this._.delete(key) : delete this._[key];
            return true;
          } else {
            var entry = this.get(key);
            var idx = entry.indexOf(val);
            if (idx != -1) {
              entry.splice(idx, 1);
              return true;
            }
          }
          return false;
        };
        Multimap.prototype.has = function (key, val) {
          var hasKey = this._map ? this._.has(key) : this._.hasOwnProperty(key);
          if (arguments.length == 1 || !hasKey)
            return hasKey;
          var entry = this.get(key) || [];
          return entry.indexOf(val) != -1;
        };
        Multimap.prototype.keys = function () {
          if (this._map)
            return this._.keys();
          return makeIterator(Object.keys(this._));
        };
        Multimap.prototype.values = function () {
          var vals = [];
          this.forEachEntry(function (entry) {
            Array.prototype.push.apply(vals, entry);
          });
          return makeIterator(vals);
        };
        Multimap.prototype.forEachEntry = function (iter) {
          var self = this;
          var keys = self.keys();
          var next;
          while (!(next = keys.next()).done) {
            iter(self.get(next.value), next.value, self);
          }
        };
        Multimap.prototype.forEach = function (iter) {
          var self = this;
          self.forEachEntry(function (entry, key) {
            entry.forEach(function (item) {
              iter(item, key, self);
            });
          });
        };
        Multimap.prototype.clear = function () {
          if (this._map) {
            this._.clear();
          } else {
            this._ = {};
          }
        };
        Object.defineProperty(Multimap.prototype, 'size', {
          configurable: false,
          enumerable: true,
          get: function () {
            var self = this;
            var keys = self.keys();
            var next, total = 0;
            while (!(next = keys.next()).done) {
              total += self.get(next.value).length;
            }
            return total;
          }
        });
        function makeIterator(array) {
          var nextIndex = 0;
          return {
            next: function () {
              return nextIndex < array.length ? {
                value: array[nextIndex++],
                done: false
              } : { done: true };
            }
          };
        }
        return Multimap;
      }();
    if (typeof exports === 'object' && module && module.exports)
      module.exports = Multimap;
    else if (typeof define === 'function' && define.amd)
      define(function () {
        return Multimap;
      });
  });
  require.define('/node_modules/shift-reducer/dist/index.js', function (module, exports, __dirname, __filename) {
    'use strict';
    exports['default'] = reduce;
    var _shiftSpec = require('/node_modules/shift-spec/dist/index.js', module);
    function transformWithSpec(_x, _x2, _x3) {
      var _left;
      var _again = true;
      _function:
        while (_again) {
          var transformer = _x, node = _x2, spec = _x3;
          _again = false;
          switch (spec.typeName) {
          case 'Enum':
          case 'String':
          case 'Number':
          case 'Boolean':
          case 'SourceSpan':
            return node;
          case 'Const':
            _x = transformer;
            _x2 = node;
            _x3 = spec.argument;
            _again = true;
            continue _function;
          case 'Maybe':
            if (!(_left = node)) {
              return _left;
            }
            _x = transformer;
            _x2 = node;
            _x3 = spec.argument;
            _again = true;
            continue _function;
          case 'List':
            return node.map(function (e) {
              return transformWithSpec(transformer, e, spec.argument);
            });
          case 'Union':
            _x = transformer;
            _x2 = node;
            _x3 = _shiftSpec['default'][node.type];
            _again = true;
            continue _function;
          default:
            var state = {};
            spec.fields.forEach(function (field) {
              var v = transformWithSpec(transformer, node[field.name], field.type);
              state[field.name] = v == null ? null : v;
            });
            if (typeof transformer['reduce' + node.type] !== 'function') {
              throw new Error('Encountered ' + node.type + ', which the provided reducer does not handle.');
            }
            return transformer['reduce' + node.type](node, state);
          }
        }
    }
    function reduce(reducer, reducible) {
      return transformWithSpec(reducer, reducible, _shiftSpec['default'][reducible.type]);
    }
    var _cloneReducer = require('/node_modules/shift-reducer/dist/clone-reducer.js', module);
    Object.defineProperty(exports, 'CloneReducer', {
      enumerable: true,
      get: function get() {
        return _cloneReducer['default'];
      }
    });
    var _monoidalReducer = require('/node_modules/shift-reducer/dist/monoidal-reducer.js', module);
    Object.defineProperty(exports, 'MonoidalReducer', {
      enumerable: true,
      get: function get() {
        return _monoidalReducer['default'];
      }
    });
  });
  require.define('/node_modules/shift-reducer/dist/monoidal-reducer.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    var _shiftSpec = require('/node_modules/shift-spec/dist/index.js', module);
    var methods = {};
    function id(x) {
      return x;
    }
    function handlerForFieldOfType(_x) {
      var _again = true;
      _function:
        while (_again) {
          var type = _x;
          _again = false;
          switch (type.typeName) {
          case 'Enum':
          case 'String':
          case 'Boolean':
          case 'Number':
          case 'SourceSpan':
            return null;
          case 'Const':
            _x = type.argument;
            _again = true;
            continue _function;
          case 'Maybe': {
              var _ret = function () {
                  var subHandler = handlerForFieldOfType(type.argument);
                  if (subHandler == null)
                    return { v: null };
                  return {
                    v: function (t) {
                      return t == null ? this.identity : subHandler.call(this, t);
                    }
                  };
                }();
              if (typeof _ret === 'object')
                return _ret.v;
            }
          case 'List': {
              var _ret2 = function () {
                  var subHandler = handlerForFieldOfType(type.argument);
                  if (subHandler == null)
                    return { v: null };
                  return {
                    v: function (t) {
                      var _this = this;
                      return this.fold(t.map(function (x) {
                        return subHandler.call(_this, x);
                      }));
                    }
                  };
                }();
              if (typeof _ret2 === 'object')
                return _ret2.v;
            }
          default:
            return id;
          }
        }
    }
    var _loop = function (typeName) {
      var type = _shiftSpec['default'][typeName];
      var handlers = {};
      type.fields.forEach(function (field) {
        var handler = handlerForFieldOfType(field.type);
        if (handler != null)
          handlers[field.name] = handler;
      });
      var fieldNames = Object.keys(handlers);
      methods['reduce' + typeName] = {
        value: function value(node, state) {
          var _this2 = this;
          return this.fold(fieldNames.map(function (fieldName) {
            return handlers[fieldName].call(_this2, state[fieldName]);
          }));
        }
      };
    };
    for (var typeName in _shiftSpec['default']) {
      _loop(typeName);
    }
    var MonoidalReducer = function () {
        function MonoidalReducer(monoid) {
          _classCallCheck(this, MonoidalReducer);
          this.identity = monoid.empty();
          var concat = monoid.prototype && monoid.prototype.concat || monoid.concat;
          this.append = function (a, b) {
            return concat.call(a, b);
          };
        }
        _createClass(MonoidalReducer, [{
            key: 'fold',
            value: function fold(list, a) {
              var _this3 = this;
              return list.reduce(function (memo, x) {
                return _this3.append(memo, x);
              }, a == null ? this.identity : a);
            }
          }]);
        return MonoidalReducer;
      }();
    exports['default'] = MonoidalReducer;
    Object.defineProperties(MonoidalReducer.prototype, methods);
  });
  require.define('/node_modules/shift-spec/dist/index.js', function (module, exports, __dirname, __filename) {
    exports.default = function () {
      var SPEC = {};
      var BOOLEAN = { typeName: 'Boolean' };
      var DOUBLE = { typeName: 'Number' };
      var STRING = { typeName: 'String' };
      function Maybe(arg) {
        return {
          typeName: 'Maybe',
          argument: arg
        };
      }
      function List(arg) {
        return {
          typeName: 'List',
          argument: arg
        };
      }
      function Const(arg) {
        return {
          typeName: 'Const',
          argument: arg
        };
      }
      function Union() {
        return {
          typeName: 'Union',
          arguments: [].slice.call(arguments, 0)
        };
      }
      var TYPE_INDICATOR = {
          typeName: 'Enum',
          values: [
            'ArrayBinding',
            'ArrayExpression',
            'ArrowExpression',
            'AssignmentExpression',
            'BinaryExpression',
            'BindingIdentifier',
            'BindingProperty',
            'BindingPropertyIdentifier',
            'BindingPropertyProperty',
            'BindingWithDefault',
            'Block',
            'BlockStatement',
            'BreakStatement',
            'CallExpression',
            'CatchClause',
            'Class',
            'ClassDeclaration',
            'ClassElement',
            'ClassExpression',
            'CompoundAssignmentExpression',
            'ComputedMemberExpression',
            'ComputedPropertyName',
            'ConditionalExpression',
            'ContinueStatement',
            'DataProperty',
            'DebuggerStatement',
            'Directive',
            'DoWhileStatement',
            'EmptyStatement',
            'Export',
            'ExportAllFrom',
            'ExportDeclaration',
            'ExportDefault',
            'ExportFrom',
            'ExportSpecifier',
            'Expression',
            'ExpressionStatement',
            'ForInStatement',
            'ForOfStatement',
            'ForStatement',
            'FormalParameters',
            'Function',
            'FunctionBody',
            'FunctionDeclaration',
            'FunctionExpression',
            'Getter',
            'IdentifierExpression',
            'IfStatement',
            'Import',
            'ImportDeclaration',
            'ImportNamespace',
            'ImportSpecifier',
            'IterationStatement',
            'LabeledStatement',
            'LiteralBooleanExpression',
            'LiteralInfinityExpression',
            'LiteralNullExpression',
            'LiteralNumericExpression',
            'LiteralRegExpExpression',
            'LiteralStringExpression',
            'MemberExpression',
            'Method',
            'MethodDefinition',
            'Module',
            'NamedObjectProperty',
            'NewExpression',
            'NewTargetExpression',
            'Node',
            'ObjectBinding',
            'ObjectExpression',
            'ObjectProperty',
            'PropertyName',
            'ReturnStatement',
            'Script',
            'Setter',
            'ShorthandProperty',
            'SourceLocation',
            'SourceSpan',
            'SpreadElement',
            'Statement',
            'StaticMemberExpression',
            'StaticPropertyName',
            'Super',
            'SwitchCase',
            'SwitchDefault',
            'SwitchStatement',
            'SwitchStatementWithDefault',
            'TemplateElement',
            'TemplateExpression',
            'ThisExpression',
            'ThrowStatement',
            'TryCatchStatement',
            'TryFinallyStatement',
            'UnaryExpression',
            'UpdateExpression',
            'VariableDeclaration',
            'VariableDeclarationStatement',
            'VariableDeclarator',
            'WhileStatement',
            'WithStatement',
            'YieldExpression',
            'YieldGeneratorExpression'
          ]
        };
      var VariableDeclarationKind = {
          typeName: 'Enum',
          values: [
            'var',
            'let',
            'const'
          ]
        };
      var CompoundAssignmentOperator = {
          typeName: 'Enum',
          values: [
            '+=',
            '-=',
            '*=',
            '/=',
            '%=',
            '<<=',
            '>>=',
            '>>>=',
            '|=',
            '^=',
            '&='
          ]
        };
      var BinaryOperator = {
          typeName: 'Enum',
          values: [
            '==',
            '!=',
            '===',
            '!==',
            '<',
            '<=',
            '>',
            '>=',
            'in',
            'instanceof',
            '<<',
            '>>',
            '>>>',
            '+',
            '-',
            '*',
            '/',
            '%',
            ',',
            '||',
            '&&',
            '|',
            '^',
            '&'
          ]
        };
      var UnaryOperator = {
          typeName: 'Enum',
          values: [
            '+',
            '-',
            '!',
            '~',
            'typeof',
            'void',
            'delete'
          ]
        };
      var UpdateOperator = {
          typeName: 'Enum',
          values: [
            '++',
            '--'
          ]
        };
      var SourceLocation = SPEC.SourceLocation = {};
      var SourceSpan = SPEC.SourceSpan = {};
      var BindingWithDefault = SPEC.BindingWithDefault = {};
      var BindingIdentifier = SPEC.BindingIdentifier = {};
      var ArrayBinding = SPEC.ArrayBinding = {};
      var ObjectBinding = SPEC.ObjectBinding = {};
      var BindingPropertyIdentifier = SPEC.BindingPropertyIdentifier = {};
      var BindingPropertyProperty = SPEC.BindingPropertyProperty = {};
      var ClassExpression = SPEC.ClassExpression = {};
      var ClassDeclaration = SPEC.ClassDeclaration = {};
      var ClassElement = SPEC.ClassElement = {};
      var Module = SPEC.Module = {};
      var Import = SPEC.Import = {};
      var ImportNamespace = SPEC.ImportNamespace = {};
      var ImportSpecifier = SPEC.ImportSpecifier = {};
      var ExportAllFrom = SPEC.ExportAllFrom = {};
      var ExportFrom = SPEC.ExportFrom = {};
      var Export = SPEC.Export = {};
      var ExportDefault = SPEC.ExportDefault = {};
      var ExportSpecifier = SPEC.ExportSpecifier = {};
      var Method = SPEC.Method = {};
      var Getter = SPEC.Getter = {};
      var Setter = SPEC.Setter = {};
      var DataProperty = SPEC.DataProperty = {};
      var ShorthandProperty = SPEC.ShorthandProperty = {};
      var ComputedPropertyName = SPEC.ComputedPropertyName = {};
      var StaticPropertyName = SPEC.StaticPropertyName = {};
      var LiteralBooleanExpression = SPEC.LiteralBooleanExpression = {};
      var LiteralInfinityExpression = SPEC.LiteralInfinityExpression = {};
      var LiteralNullExpression = SPEC.LiteralNullExpression = {};
      var LiteralNumericExpression = SPEC.LiteralNumericExpression = {};
      var LiteralRegExpExpression = SPEC.LiteralRegExpExpression = {};
      var LiteralStringExpression = SPEC.LiteralStringExpression = {};
      var ArrayExpression = SPEC.ArrayExpression = {};
      var ArrowExpression = SPEC.ArrowExpression = {};
      var AssignmentExpression = SPEC.AssignmentExpression = {};
      var BinaryExpression = SPEC.BinaryExpression = {};
      var CallExpression = SPEC.CallExpression = {};
      var CompoundAssignmentExpression = SPEC.CompoundAssignmentExpression = {};
      var ComputedMemberExpression = SPEC.ComputedMemberExpression = {};
      var ConditionalExpression = SPEC.ConditionalExpression = {};
      var FunctionExpression = SPEC.FunctionExpression = {};
      var IdentifierExpression = SPEC.IdentifierExpression = {};
      var NewExpression = SPEC.NewExpression = {};
      var NewTargetExpression = SPEC.NewTargetExpression = {};
      var ObjectExpression = SPEC.ObjectExpression = {};
      var UnaryExpression = SPEC.UnaryExpression = {};
      var StaticMemberExpression = SPEC.StaticMemberExpression = {};
      var TemplateExpression = SPEC.TemplateExpression = {};
      var ThisExpression = SPEC.ThisExpression = {};
      var UpdateExpression = SPEC.UpdateExpression = {};
      var YieldExpression = SPEC.YieldExpression = {};
      var YieldGeneratorExpression = SPEC.YieldGeneratorExpression = {};
      var BlockStatement = SPEC.BlockStatement = {};
      var BreakStatement = SPEC.BreakStatement = {};
      var ContinueStatement = SPEC.ContinueStatement = {};
      var DebuggerStatement = SPEC.DebuggerStatement = {};
      var DoWhileStatement = SPEC.DoWhileStatement = {};
      var EmptyStatement = SPEC.EmptyStatement = {};
      var ExpressionStatement = SPEC.ExpressionStatement = {};
      var ForInStatement = SPEC.ForInStatement = {};
      var ForOfStatement = SPEC.ForOfStatement = {};
      var ForStatement = SPEC.ForStatement = {};
      var IfStatement = SPEC.IfStatement = {};
      var LabeledStatement = SPEC.LabeledStatement = {};
      var ReturnStatement = SPEC.ReturnStatement = {};
      var SwitchStatement = SPEC.SwitchStatement = {};
      var SwitchStatementWithDefault = SPEC.SwitchStatementWithDefault = {};
      var ThrowStatement = SPEC.ThrowStatement = {};
      var TryCatchStatement = SPEC.TryCatchStatement = {};
      var TryFinallyStatement = SPEC.TryFinallyStatement = {};
      var VariableDeclarationStatement = SPEC.VariableDeclarationStatement = {};
      var WhileStatement = SPEC.WhileStatement = {};
      var WithStatement = SPEC.WithStatement = {};
      var Block = SPEC.Block = {};
      var CatchClause = SPEC.CatchClause = {};
      var Directive = SPEC.Directive = {};
      var FormalParameters = SPEC.FormalParameters = {};
      var FunctionBody = SPEC.FunctionBody = {};
      var FunctionDeclaration = SPEC.FunctionDeclaration = {};
      var Script = SPEC.Script = {};
      var SpreadElement = SPEC.SpreadElement = {};
      var Super = SPEC.Super = {};
      var SwitchCase = SPEC.SwitchCase = {};
      var SwitchDefault = SPEC.SwitchDefault = {};
      var TemplateElement = SPEC.TemplateElement = {};
      var VariableDeclaration = SPEC.VariableDeclaration = {};
      var VariableDeclarator = SPEC.VariableDeclarator = {};
      var Class = Union(ClassExpression, ClassDeclaration);
      var BindingProperty = Union(BindingPropertyIdentifier, BindingPropertyProperty);
      var ExportDeclaration = Union(ExportAllFrom, ExportFrom, Export, ExportDefault);
      var ImportDeclaration = Union(Import, ImportNamespace);
      var MethodDefinition = Union(Method, Getter, Setter);
      var NamedObjectProperty = Union(MethodDefinition, DataProperty);
      var ObjectProperty = Union(NamedObjectProperty, ShorthandProperty);
      var PropertyName = Union(ComputedPropertyName, StaticPropertyName);
      var MemberExpression = Union(ComputedMemberExpression, StaticMemberExpression);
      var Expression = Union(MemberExpression, ClassExpression, LiteralBooleanExpression, LiteralInfinityExpression, LiteralNullExpression, LiteralNumericExpression, LiteralRegExpExpression, LiteralStringExpression, ArrayExpression, ArrowExpression, AssignmentExpression, BinaryExpression, CallExpression, CompoundAssignmentExpression, ConditionalExpression, FunctionExpression, IdentifierExpression, NewExpression, NewTargetExpression, ObjectExpression, UnaryExpression, TemplateExpression, ThisExpression, UpdateExpression, YieldExpression, YieldGeneratorExpression);
      var IterationStatement = Union(DoWhileStatement, ForInStatement, ForOfStatement, ForStatement, WhileStatement);
      var Statement = Union(IterationStatement, ClassDeclaration, BlockStatement, BreakStatement, ContinueStatement, DebuggerStatement, EmptyStatement, ExpressionStatement, IfStatement, LabeledStatement, ReturnStatement, SwitchStatement, SwitchStatementWithDefault, ThrowStatement, TryCatchStatement, TryFinallyStatement, VariableDeclarationStatement, WithStatement, FunctionDeclaration);
      var Node = Union(Statement, Expression, PropertyName, ObjectProperty, ImportDeclaration, ExportDeclaration, BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding, BindingProperty, ClassElement, Module, ImportSpecifier, ExportSpecifier, Block, CatchClause, Directive, FormalParameters, FunctionBody, Script, SpreadElement, Super, SwitchCase, SwitchDefault, TemplateElement, VariableDeclaration, VariableDeclarator);
      var Function = Union(FunctionExpression, FunctionDeclaration);
      SourceLocation.typeName = 'SourceLocation';
      SourceLocation.fields = [
        {
          name: 'line',
          type: DOUBLE
        },
        {
          name: 'column',
          type: DOUBLE
        },
        {
          name: 'offset',
          type: DOUBLE
        }
      ];
      SourceSpan.typeName = 'SourceSpan';
      SourceSpan.fields = [
        {
          name: 'source',
          type: Maybe(STRING)
        },
        {
          name: 'start',
          type: SourceLocation
        },
        {
          name: 'end',
          type: SourceLocation
        }
      ];
      BindingWithDefault.typeName = 'BindingWithDefault';
      BindingWithDefault.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'BindingWithDefault'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'binding',
          type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression)
        },
        {
          name: 'init',
          type: Expression
        }
      ];
      BindingIdentifier.typeName = 'BindingIdentifier';
      BindingIdentifier.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'BindingIdentifier'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'name',
          type: STRING
        }
      ];
      ArrayBinding.typeName = 'ArrayBinding';
      ArrayBinding.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ArrayBinding'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'elements',
          type: List(Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault)))
        },
        {
          name: 'restElement',
          type: Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression))
        }
      ];
      ObjectBinding.typeName = 'ObjectBinding';
      ObjectBinding.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ObjectBinding'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'properties',
          type: List(BindingProperty)
        }
      ];
      BindingPropertyIdentifier.typeName = 'BindingPropertyIdentifier';
      BindingPropertyIdentifier.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'BindingPropertyIdentifier'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'binding',
          type: BindingIdentifier
        },
        {
          name: 'init',
          type: Maybe(Expression)
        }
      ];
      BindingPropertyProperty.typeName = 'BindingPropertyProperty';
      BindingPropertyProperty.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'BindingPropertyProperty'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'name',
          type: PropertyName
        },
        {
          name: 'binding',
          type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault)
        }
      ];
      ClassExpression.typeName = 'ClassExpression';
      ClassExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ClassExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'name',
          type: Maybe(BindingIdentifier)
        },
        {
          name: 'super',
          type: Maybe(Expression)
        },
        {
          name: 'elements',
          type: List(ClassElement)
        }
      ];
      ClassDeclaration.typeName = 'ClassDeclaration';
      ClassDeclaration.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ClassDeclaration'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'name',
          type: BindingIdentifier
        },
        {
          name: 'super',
          type: Maybe(Expression)
        },
        {
          name: 'elements',
          type: List(ClassElement)
        }
      ];
      ClassElement.typeName = 'ClassElement';
      ClassElement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ClassElement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'isStatic',
          type: BOOLEAN
        },
        {
          name: 'method',
          type: MethodDefinition
        }
      ];
      Module.typeName = 'Module';
      Module.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'Module'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'directives',
          type: List(Directive)
        },
        {
          name: 'items',
          type: List(Union(ImportDeclaration, ExportDeclaration, Statement))
        }
      ];
      Import.typeName = 'Import';
      Import.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'Import'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'moduleSpecifier',
          type: STRING
        },
        {
          name: 'defaultBinding',
          type: Maybe(BindingIdentifier)
        },
        {
          name: 'namedImports',
          type: List(ImportSpecifier)
        }
      ];
      ImportNamespace.typeName = 'ImportNamespace';
      ImportNamespace.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ImportNamespace'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'moduleSpecifier',
          type: STRING
        },
        {
          name: 'defaultBinding',
          type: Maybe(BindingIdentifier)
        },
        {
          name: 'namespaceBinding',
          type: BindingIdentifier
        }
      ];
      ImportSpecifier.typeName = 'ImportSpecifier';
      ImportSpecifier.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ImportSpecifier'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'name',
          type: Maybe(STRING)
        },
        {
          name: 'binding',
          type: BindingIdentifier
        }
      ];
      ExportAllFrom.typeName = 'ExportAllFrom';
      ExportAllFrom.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ExportAllFrom'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'moduleSpecifier',
          type: STRING
        }
      ];
      ExportFrom.typeName = 'ExportFrom';
      ExportFrom.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ExportFrom'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'namedExports',
          type: List(ExportSpecifier)
        },
        {
          name: 'moduleSpecifier',
          type: Maybe(STRING)
        }
      ];
      Export.typeName = 'Export';
      Export.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'Export'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'declaration',
          type: Union(FunctionDeclaration, ClassDeclaration, VariableDeclaration)
        }
      ];
      ExportDefault.typeName = 'ExportDefault';
      ExportDefault.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ExportDefault'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'body',
          type: Union(FunctionDeclaration, ClassDeclaration, Expression)
        }
      ];
      ExportSpecifier.typeName = 'ExportSpecifier';
      ExportSpecifier.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ExportSpecifier'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'name',
          type: Maybe(STRING)
        },
        {
          name: 'exportedName',
          type: STRING
        }
      ];
      Method.typeName = 'Method';
      Method.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'Method'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'name',
          type: PropertyName
        },
        {
          name: 'isGenerator',
          type: BOOLEAN
        },
        {
          name: 'params',
          type: FormalParameters
        },
        {
          name: 'body',
          type: FunctionBody
        }
      ];
      Getter.typeName = 'Getter';
      Getter.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'Getter'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'name',
          type: PropertyName
        },
        {
          name: 'body',
          type: FunctionBody
        }
      ];
      Setter.typeName = 'Setter';
      Setter.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'Setter'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'name',
          type: PropertyName
        },
        {
          name: 'param',
          type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault)
        },
        {
          name: 'body',
          type: FunctionBody
        }
      ];
      DataProperty.typeName = 'DataProperty';
      DataProperty.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'DataProperty'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'name',
          type: PropertyName
        },
        {
          name: 'expression',
          type: Expression
        }
      ];
      ShorthandProperty.typeName = 'ShorthandProperty';
      ShorthandProperty.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ShorthandProperty'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'name',
          type: STRING
        }
      ];
      ComputedPropertyName.typeName = 'ComputedPropertyName';
      ComputedPropertyName.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ComputedPropertyName'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'expression',
          type: Expression
        }
      ];
      StaticPropertyName.typeName = 'StaticPropertyName';
      StaticPropertyName.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'StaticPropertyName'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'value',
          type: STRING
        }
      ];
      LiteralBooleanExpression.typeName = 'LiteralBooleanExpression';
      LiteralBooleanExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'LiteralBooleanExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'value',
          type: BOOLEAN
        }
      ];
      LiteralInfinityExpression.typeName = 'LiteralInfinityExpression';
      LiteralInfinityExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'LiteralInfinityExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        }
      ];
      LiteralNullExpression.typeName = 'LiteralNullExpression';
      LiteralNullExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'LiteralNullExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        }
      ];
      LiteralNumericExpression.typeName = 'LiteralNumericExpression';
      LiteralNumericExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'LiteralNumericExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'value',
          type: DOUBLE
        }
      ];
      LiteralRegExpExpression.typeName = 'LiteralRegExpExpression';
      LiteralRegExpExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'LiteralRegExpExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'pattern',
          type: STRING
        },
        {
          name: 'flags',
          type: STRING
        }
      ];
      LiteralStringExpression.typeName = 'LiteralStringExpression';
      LiteralStringExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'LiteralStringExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'value',
          type: STRING
        }
      ];
      ArrayExpression.typeName = 'ArrayExpression';
      ArrayExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ArrayExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'elements',
          type: List(Maybe(Union(SpreadElement, Expression)))
        }
      ];
      ArrowExpression.typeName = 'ArrowExpression';
      ArrowExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ArrowExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'params',
          type: FormalParameters
        },
        {
          name: 'body',
          type: Union(FunctionBody, Expression)
        }
      ];
      AssignmentExpression.typeName = 'AssignmentExpression';
      AssignmentExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'AssignmentExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'binding',
          type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression)
        },
        {
          name: 'expression',
          type: Expression
        }
      ];
      BinaryExpression.typeName = 'BinaryExpression';
      BinaryExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'BinaryExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'operator',
          type: BinaryOperator
        },
        {
          name: 'left',
          type: Expression
        },
        {
          name: 'right',
          type: Expression
        }
      ];
      CallExpression.typeName = 'CallExpression';
      CallExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'CallExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'callee',
          type: Union(Expression, Super)
        },
        {
          name: 'arguments',
          type: List(Union(SpreadElement, Expression))
        }
      ];
      CompoundAssignmentExpression.typeName = 'CompoundAssignmentExpression';
      CompoundAssignmentExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'CompoundAssignmentExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'operator',
          type: CompoundAssignmentOperator
        },
        {
          name: 'binding',
          type: Union(BindingIdentifier, MemberExpression)
        },
        {
          name: 'expression',
          type: Expression
        }
      ];
      ComputedMemberExpression.typeName = 'ComputedMemberExpression';
      ComputedMemberExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ComputedMemberExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'object',
          type: Union(Expression, Super)
        },
        {
          name: 'expression',
          type: Expression
        }
      ];
      ConditionalExpression.typeName = 'ConditionalExpression';
      ConditionalExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ConditionalExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'test',
          type: Expression
        },
        {
          name: 'consequent',
          type: Expression
        },
        {
          name: 'alternate',
          type: Expression
        }
      ];
      FunctionExpression.typeName = 'FunctionExpression';
      FunctionExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'FunctionExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'isGenerator',
          type: BOOLEAN
        },
        {
          name: 'name',
          type: Maybe(BindingIdentifier)
        },
        {
          name: 'params',
          type: FormalParameters
        },
        {
          name: 'body',
          type: FunctionBody
        }
      ];
      IdentifierExpression.typeName = 'IdentifierExpression';
      IdentifierExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'IdentifierExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'name',
          type: STRING
        }
      ];
      NewExpression.typeName = 'NewExpression';
      NewExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'NewExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'callee',
          type: Expression
        },
        {
          name: 'arguments',
          type: List(Union(SpreadElement, Expression))
        }
      ];
      NewTargetExpression.typeName = 'NewTargetExpression';
      NewTargetExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'NewTargetExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        }
      ];
      ObjectExpression.typeName = 'ObjectExpression';
      ObjectExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ObjectExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'properties',
          type: List(ObjectProperty)
        }
      ];
      UnaryExpression.typeName = 'UnaryExpression';
      UnaryExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'UnaryExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'operator',
          type: UnaryOperator
        },
        {
          name: 'operand',
          type: Expression
        }
      ];
      StaticMemberExpression.typeName = 'StaticMemberExpression';
      StaticMemberExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'StaticMemberExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'object',
          type: Union(Expression, Super)
        },
        {
          name: 'property',
          type: STRING
        }
      ];
      TemplateExpression.typeName = 'TemplateExpression';
      TemplateExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'TemplateExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'tag',
          type: Maybe(Expression)
        },
        {
          name: 'elements',
          type: List(Union(Expression, TemplateElement))
        }
      ];
      ThisExpression.typeName = 'ThisExpression';
      ThisExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ThisExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        }
      ];
      UpdateExpression.typeName = 'UpdateExpression';
      UpdateExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'UpdateExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'isPrefix',
          type: BOOLEAN
        },
        {
          name: 'operator',
          type: UpdateOperator
        },
        {
          name: 'operand',
          type: Union(BindingIdentifier, MemberExpression)
        }
      ];
      YieldExpression.typeName = 'YieldExpression';
      YieldExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'YieldExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'expression',
          type: Maybe(Expression)
        }
      ];
      YieldGeneratorExpression.typeName = 'YieldGeneratorExpression';
      YieldGeneratorExpression.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'YieldGeneratorExpression'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'expression',
          type: Expression
        }
      ];
      BlockStatement.typeName = 'BlockStatement';
      BlockStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'BlockStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'block',
          type: Block
        }
      ];
      BreakStatement.typeName = 'BreakStatement';
      BreakStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'BreakStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'label',
          type: Maybe(STRING)
        }
      ];
      ContinueStatement.typeName = 'ContinueStatement';
      ContinueStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ContinueStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'label',
          type: Maybe(STRING)
        }
      ];
      DebuggerStatement.typeName = 'DebuggerStatement';
      DebuggerStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'DebuggerStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        }
      ];
      DoWhileStatement.typeName = 'DoWhileStatement';
      DoWhileStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'DoWhileStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'body',
          type: Statement
        },
        {
          name: 'test',
          type: Expression
        }
      ];
      EmptyStatement.typeName = 'EmptyStatement';
      EmptyStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'EmptyStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        }
      ];
      ExpressionStatement.typeName = 'ExpressionStatement';
      ExpressionStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ExpressionStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'expression',
          type: Expression
        }
      ];
      ForInStatement.typeName = 'ForInStatement';
      ForInStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ForInStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'left',
          type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression)
        },
        {
          name: 'right',
          type: Expression
        },
        {
          name: 'body',
          type: Statement
        }
      ];
      ForOfStatement.typeName = 'ForOfStatement';
      ForOfStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ForOfStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'left',
          type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression)
        },
        {
          name: 'right',
          type: Expression
        },
        {
          name: 'body',
          type: Statement
        }
      ];
      ForStatement.typeName = 'ForStatement';
      ForStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ForStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'init',
          type: Maybe(Union(VariableDeclaration, Expression))
        },
        {
          name: 'test',
          type: Maybe(Expression)
        },
        {
          name: 'update',
          type: Maybe(Expression)
        },
        {
          name: 'body',
          type: Statement
        }
      ];
      IfStatement.typeName = 'IfStatement';
      IfStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'IfStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'test',
          type: Expression
        },
        {
          name: 'consequent',
          type: Statement
        },
        {
          name: 'alternate',
          type: Maybe(Statement)
        }
      ];
      LabeledStatement.typeName = 'LabeledStatement';
      LabeledStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'LabeledStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'label',
          type: STRING
        },
        {
          name: 'body',
          type: Statement
        }
      ];
      ReturnStatement.typeName = 'ReturnStatement';
      ReturnStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ReturnStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'expression',
          type: Maybe(Expression)
        }
      ];
      SwitchStatement.typeName = 'SwitchStatement';
      SwitchStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'SwitchStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'discriminant',
          type: Expression
        },
        {
          name: 'cases',
          type: List(SwitchCase)
        }
      ];
      SwitchStatementWithDefault.typeName = 'SwitchStatementWithDefault';
      SwitchStatementWithDefault.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'SwitchStatementWithDefault'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'discriminant',
          type: Expression
        },
        {
          name: 'preDefaultCases',
          type: List(SwitchCase)
        },
        {
          name: 'defaultCase',
          type: SwitchDefault
        },
        {
          name: 'postDefaultCases',
          type: List(SwitchCase)
        }
      ];
      ThrowStatement.typeName = 'ThrowStatement';
      ThrowStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'ThrowStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'expression',
          type: Expression
        }
      ];
      TryCatchStatement.typeName = 'TryCatchStatement';
      TryCatchStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'TryCatchStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'body',
          type: Block
        },
        {
          name: 'catchClause',
          type: CatchClause
        }
      ];
      TryFinallyStatement.typeName = 'TryFinallyStatement';
      TryFinallyStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'TryFinallyStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'body',
          type: Block
        },
        {
          name: 'catchClause',
          type: Maybe(CatchClause)
        },
        {
          name: 'finalizer',
          type: Block
        }
      ];
      VariableDeclarationStatement.typeName = 'VariableDeclarationStatement';
      VariableDeclarationStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'VariableDeclarationStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'declaration',
          type: VariableDeclaration
        }
      ];
      WhileStatement.typeName = 'WhileStatement';
      WhileStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'WhileStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'test',
          type: Expression
        },
        {
          name: 'body',
          type: Statement
        }
      ];
      WithStatement.typeName = 'WithStatement';
      WithStatement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'WithStatement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'object',
          type: Expression
        },
        {
          name: 'body',
          type: Statement
        }
      ];
      Block.typeName = 'Block';
      Block.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'Block'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'statements',
          type: List(Statement)
        }
      ];
      CatchClause.typeName = 'CatchClause';
      CatchClause.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'CatchClause'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'binding',
          type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression)
        },
        {
          name: 'body',
          type: Block
        }
      ];
      Directive.typeName = 'Directive';
      Directive.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'Directive'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'rawValue',
          type: STRING
        }
      ];
      FormalParameters.typeName = 'FormalParameters';
      FormalParameters.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'FormalParameters'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'items',
          type: List(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault))
        },
        {
          name: 'rest',
          type: Maybe(BindingIdentifier)
        }
      ];
      FunctionBody.typeName = 'FunctionBody';
      FunctionBody.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'FunctionBody'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'directives',
          type: List(Directive)
        },
        {
          name: 'statements',
          type: List(Statement)
        }
      ];
      FunctionDeclaration.typeName = 'FunctionDeclaration';
      FunctionDeclaration.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'FunctionDeclaration'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'isGenerator',
          type: BOOLEAN
        },
        {
          name: 'name',
          type: BindingIdentifier
        },
        {
          name: 'params',
          type: FormalParameters
        },
        {
          name: 'body',
          type: FunctionBody
        }
      ];
      Script.typeName = 'Script';
      Script.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'Script'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'directives',
          type: List(Directive)
        },
        {
          name: 'statements',
          type: List(Statement)
        }
      ];
      SpreadElement.typeName = 'SpreadElement';
      SpreadElement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'SpreadElement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'expression',
          type: Expression
        }
      ];
      Super.typeName = 'Super';
      Super.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'Super'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        }
      ];
      SwitchCase.typeName = 'SwitchCase';
      SwitchCase.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'SwitchCase'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'test',
          type: Expression
        },
        {
          name: 'consequent',
          type: List(Statement)
        }
      ];
      SwitchDefault.typeName = 'SwitchDefault';
      SwitchDefault.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'SwitchDefault'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'consequent',
          type: List(Statement)
        }
      ];
      TemplateElement.typeName = 'TemplateElement';
      TemplateElement.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'TemplateElement'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'rawValue',
          type: STRING
        }
      ];
      VariableDeclaration.typeName = 'VariableDeclaration';
      VariableDeclaration.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'VariableDeclaration'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'kind',
          type: VariableDeclarationKind
        },
        {
          name: 'declarators',
          type: List(VariableDeclarator)
        }
      ];
      VariableDeclarator.typeName = 'VariableDeclarator';
      VariableDeclarator.fields = [
        {
          name: 'type',
          type: Const(TYPE_INDICATOR),
          value: 'VariableDeclarator'
        },
        {
          name: 'loc',
          type: Maybe(SourceSpan)
        },
        {
          name: 'binding',
          type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression)
        },
        {
          name: 'init',
          type: Maybe(Expression)
        }
      ];
      return SPEC;
    }();
  });
  require.define('/node_modules/shift-reducer/dist/clone-reducer.js', function (module, exports, __dirname, __filename) {
    'use strict';
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    var _shiftSpec = require('/node_modules/shift-spec/dist/index.js', module);
    var CloneReducer = function CloneReducer() {
      _classCallCheck(this, CloneReducer);
    };
    exports['default'] = CloneReducer;
    for (var typeName in _shiftSpec['default']) {
      var type = _shiftSpec['default'][typeName];
      Object.defineProperty(CloneReducer.prototype, 'reduce' + typeName, {
        value: function value(node, state) {
          return state;
        }
      });
    }
  });
  require.define('/dist/scope-lookup.js', function (module, exports, __dirname, __filename) {
    'use strict';
    var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
    Object.defineProperty(exports, '__esModule', { value: true });
    var _multimap = require('/node_modules/multimap/index.js', module);
    var _MultiMap = _interopRequireWildcard(_multimap);
    var _scope = require('/dist/scope.js', module);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    var MultiMap = _MultiMap.default;
    var ScopeLookup = function () {
        function ScopeLookup(globalScope) {
          var _this = this;
          _classCallCheck(this, ScopeLookup);
          this.scope = globalScope;
          this.variableMap = new MultiMap;
          var addVariable = function addVariable(v) {
            v.declarations.forEach(function (decl) {
              return _this.variableMap.set(decl.node, v);
            });
            v.references.forEach(function (ref) {
              if (!_this.variableMap.has(ref.node) || _this.variableMap.get(ref.node).indexOf(v) === -1) {
                _this.variableMap.set(ref.node, v);
              }
            });
          };
          (function getVariables(scope) {
            scope.children.forEach(getVariables);
            scope.variables.forEach(addVariable);
          }(globalScope));
        }
        _createClass(ScopeLookup, [
          {
            key: 'lookup',
            value: function lookup(node) {
              return this.variableMap.get(node);
            }
          },
          {
            key: 'isGlobal',
            value: function isGlobal(node) {
              return this.scope instanceof _scope.GlobalScope && this.scope.has(node);
            }
          }
        ]);
        return ScopeLookup;
      }();
    exports.default = ScopeLookup;
  });
  global.scope = require('/dist/index.js');
}.call(this, this));